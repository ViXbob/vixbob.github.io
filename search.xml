<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卢卡斯定理学习笔记]]></title>
    <url>%2F2018%2F09%2F08%2FExLucas%2F</url>
    <content type="text"><![CDATA[卢卡斯定理 常用于求解\(\binom{n}{m} (mod \ \ P)\) , 且\(n\), \(m\)值域特别大, 而 \(P\) 的值域比较小 \(P\)为素数 直接记定理就好了 : \[ \binom{n}{m} (mod \ \ P)= \binom{n / P}{m / P} \cdot \binom {n \% P}{m \% P} (mod\ \ P) \] 然后我们预处理出\(1 \sim P\)的阶乘和逆元, 那么求这个组合数的复杂度就是\(O(P + log_P^{n})\) 代码 : 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;int n, m, fac[maxn], P;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int ksm(int x, int k)&#123; int cnt = 1; while(k)&#123; if(k &amp; 1)cnt = 1ll * cnt * x % P; x = 1ll * x * x % P; k &gt;&gt;= 1; &#125; return cnt;&#125;inline int C(int n, int m, int P)&#123; if(n &lt; m)return 0; return (int)(1ll * fac[n] * ksm(fac[n - m], P - 2) % P * ksm(fac[m], P - 2) % P);&#125;inline Lucas(int n, int m, int P)&#123; if(n == 0 || m == 0)return 1; return (int)(1ll * Lucas(n / P, m / P, P) * C(n % P, m % P, P) % P);&#125;int main()&#123; n = read(); m = read(); P = read(); fac[0] = 1; for(register int i = 1; i &lt;= P; i++) fac[i] = 1ll * fac[i - 1] * i % P; cout &lt;&lt; Lucas(n, m, P); return 0;&#125; \(P\) 不为素数 其实这个东西和卢卡斯定理并没有什么关系 因为\(P\)不为素数, 所以 : \[ P = \prod P_i^{a_i} \] 我们考虑求出 \[ \binom {n}{m} (mod \ \ P_i^{a_i}) \] 然后直接用\(CRT\)合并就是答案了 那么现在问题转化为了如何快速求出\(\binom{n}{m}(mod\ \ P_i^{a_i})\)了 因为实在膜 \(P_i^{a_i}\) 的意义下, 所以阶乘其实是有循环节的, 我们可以考虑直接暴力处理循环节和不完整的循环 难道这样就好了吗, 事实上并没有这么简单 因为\(P_i^{a_i}\)是\(P_i\)的倍数, 所以很有可能再膜意义下就直接变为零了, 但是事实上并不是这样的, 我们观察组合数的公式 : \[ \binom {n}{m} = \frac{n!}{(n - m)!m!} \] 所以分母和分子的\(P_i\)是可已被约掉的, 所以我们不能直接取膜, 我们再考虑把是\(P_i\)的倍数的数给单独提出来搞一下 那么 \[ fac(n) = \big(fac(\lfloor \frac{n}{P_i^{a_i}} \rfloor) \cdot P_i^{\lfloor \frac{n}{P_i^{a_i}} \rfloor}\big) \cdot \big(\prod_{i = 1}^{P_i^{a_i}} i\big) \cdot \big(\prod_{i = 1}^{n \% P_i^{a_i}} i\big) (mod \ \ P_i^{a_i}) \] 我们发现这个是一个递归式, 那么直接递归就好了, 特别的如果\(n = 0\)就返回\(1\) 需要注意的是\(P_i\)这个东西不能在递归的时候直接乘上, 我们考虑, 在递归完之后, 或者递归之前直接处理出来就好了 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;typedef long long LL;using namespace std;LL n, m, P;inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL ksm(LL x, LL k, LL P)&#123; LL cnt = 1; while(k)&#123; if(k &amp; 1)cnt = cnt * x % P; x = x * x % P; k &gt;&gt;= 1; &#125; return cnt;&#125;inline LL Exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(b == 0)&#123;x = 1; y = 0; return a;&#125; LL x0 = 0, y0 = 0; LL d = Exgcd(b, a % b, y0, x0); x = x0; y = y0 - ((a / b) * x0); return d;&#125;inline LL fac(LL n, LL Pi, LL Pk)&#123; if(n == 0)return 1; LL rnt = 1; for(register int i = 2; i &lt;= Pk; i++) if(i % Pi)rnt = rnt * i % Pk; rnt = ksm(rnt, n / Pk, Pk); for(register int i = 2; i &lt;= n % Pk; i++) if(i % Pi)rnt = rnt * i % Pk; return rnt * fac(n / Pi, Pi, Pk) % Pk;&#125;inline LL inv(LL x, LL P)&#123; LL inv, tmp; Exgcd(x, P, inv, tmp); return (inv + P) % P;&#125;inline LL ExLucas(LL n, LL m, LL Pi, LL Pk)&#123; LL C1 = fac(n, Pi, Pk), C2 = fac(n - m, Pi, Pk), C3 = fac(m, Pi, Pk); LL tim = 0; for(register LL i = n; i; i /= Pi)tim += i / Pi; for(register LL i = n - m; i; i /= Pi)tim -= i / Pi; for(register LL i = m; i; i /= Pi)tim -= i / Pi; return C1 * inv(C2, Pk) % Pk * inv(C3, Pk) % Pk * ksm(Pi, tim, Pk) % Pk;&#125;inline LL China(LL n, LL m, LL P)&#123; LL A = 0, M = P, Pk = 1; for(register LL i = 2; i &lt;= P; i++) if(P % i == 0)&#123; Pk = 1; while(P % i == 0)Pk *= i, P /= i; A = (A + ExLucas(n, m, i, Pk) * inv(M / Pk, Pk) % M * (M / Pk) % M) % M; &#125; return (A + M) % M;&#125;int main()&#123; n = read(); m = read(); P = read(); cout &lt;&lt; China(n, m, P); return 0;&#125;]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>CRT</tag>
        <tag>Exgcd</tag>
        <tag>ExLucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水题记录1.0]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%B0%B4%E9%A2%98%E8%AE%B0%E5%BD%951.0%2F</url>
    <content type="text"><![CDATA[12/50 水题记录 1.BZOJ1951古代猪文 题目大意 : 要求求出 \[ G^{\sum \{C_{K}^{N}, K\mid N\}} \% 999911659 \] \(N \leq 10^9 , G \leq 10^9\) 题解 : 我们考虑一个事实 \[ G ^ P = G ^ {P \% \phi(P)} (mod \ \ P) \] 因为 \(P\) 是质数所以\(G^{\phi(P)} = 1(mod \ \ P)\), 然后可以知道, \[ G ^ P = G ^ {P + k \cdot \phi(P)} (mod \ \ P) \] 即与上面那个式子等价 然后我们考虑怎么求 \[ \sum \{C_{K}^{N}, K\mid N\} \% \phi(P) \] 因为\(\phi(P)\)不是质数我们考虑用\(Lucas\) \[ \phi(P) = P - 1 = 2 \cdot 3 \cdot 4679 \cdot 35617 \] 这样就很水了, 因为对于\(\phi(P)\)的每个素因子的幂都是\(1\) 所以直接对于每个素因子用一下\(Lucas\), 最后直接\(CRT\)合并一下素膜数就好了, 并不用ExCRT, 水水水 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4e4 + 5;const int P[5] = &#123;999911659, 2, 3, 4679, 35617&#125;;int fac[5][maxn], G, N, num[maxn], a[5];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int ksm(int x, int k, int mod)&#123; if(x == mod)return 0; int cnt = 1; while(k)&#123; if(k &amp; 1)cnt = 1ll * cnt * x % mod; x = 1ll * x * x % mod; k &gt;&gt;= 1; &#125; return cnt;&#125;inline int com(int n, int m, int k)&#123; if(m &gt; n)return 0; return (int)(1ll * fac[k][n] * ksm(fac[k][n - m], P[k] - 2, P[k]) % P[k] * ksm(fac[k][m], P[k] - 2, P[k]) % P[k]);&#125;inline int C(int n, int m, int k)&#123; if(m == 0 || n == 0)return 1; return (int)(1ll * C(n / P[k], m / P[k], k) * com(n % P[k], m % P[k], k) % P[k]);&#125;inline int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0)&#123;x = 1; y = 0; return a;&#125; int x0 = 0, y0 = 0; int d = exgcd(b, a % b, y0, x0); x = x0; y = y0 - ((a / b) * x0); return d;&#125;inline int china(int *a, const int *m, int n)&#123; int A = 0, M = 1, tmp; for(register int i = 1; i &lt;= n; i++)M *= m[i]; for(register int i = 1; i &lt;= n; i++)&#123; int Mi = M / m[i], inv; exgcd(Mi, m[i], inv, tmp); A = (A + 1ll * a[i] * Mi * inv) % M; &#125; return (A % M + M) % M;&#125;int main()&#123; N = read(); G = read(); for(register int i = 1; i * i &lt;= N; i++) if(N % i == 0)&#123; num[++num[0]] = i; if(i * i != N)num[++num[0]] = N / i; &#125; for(register int k = 1; k &lt; 5; k++)&#123; fac[k][0] = 1; for(register int i = 1; i &lt; maxn; i++) fac[k][i] = 1ll * fac[k][i - 1] * i % P[k]; &#125; for(register int k = 1; k &lt; 5; k++) for(register int i = 1; i &lt;= num[0]; i++) a[k] = (a[k] + C(N, num[i], k)) % P[k]; /*for(register int i = 1; i &lt;= num[0]; i++) cout &lt;&lt; "num[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; num[i] &lt;&lt; endl; for(register int i = 1; i &lt; 5; i++) cout &lt;&lt; "a[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; a[i] &lt;&lt; endl; int o = china(a, P, 4); cout &lt;&lt; "P = " &lt;&lt; o &lt;&lt; endl; cout &lt;&lt; "G = " &lt;&lt; G &lt;&lt; endl;*/ cout &lt;&lt; ksm(G, china(a, P, 4), P[0]); return 0;&#125; 2.BZOJ2142礼物 题目大意 : 有\(n\)件礼物, \(m\)个人, 要求每个人分得\(w_i\)件礼物, 问有法案数对\(P\)取膜后的结果 题解 : 很显然答案应该是 \[ \binom {n}{\sum w_i} \prod_{i = 1}^{m} \binom{w_i}{\sum_{j = 1}^{m}w_j} (mod \ \ P) \] 然后因为题目不保证\(P\)为素数, 所以直接 $ ExLucas $ 就好了 如果不会\(ExLucas\)的, 可以点击这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL n, m, P, a[maxn], s[maxn];inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL ksm(LL x, LL k, LL P)&#123; LL cnt = 1; while(k)&#123; if(k &amp; 1)cnt = cnt * x % P; x = x * x % P; k &gt;&gt;= 1; &#125; return cnt;&#125;inline LL Exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(b == 0)&#123;x = 1; y = 0; return a;&#125; LL x0 = 0, y0 = 0; LL d = Exgcd(b, a % b, y0, x0); x = x0; y = y0 - ((a / b) * x0); return d;&#125;inline LL inv(LL x, LL P)&#123; LL inv, tmp; Exgcd(x, P, inv, tmp); return (inv + P) % P;&#125;inline LL fac(LL n, LL Pi, LL Pk)&#123; if(n == 0)return 1; LL rnt = 1; for(register LL i = 2; i &lt;= Pk; i++) if(i % Pi)rnt = rnt * i % Pk; rnt = ksm(rnt, n / Pk, Pk); for(register LL i = 2; i &lt;= n % Pk; i++) if(i % Pi)rnt = rnt * i % Pk; return rnt * fac(n / Pi, Pi, Pk) % Pk;&#125;inline LL ExLucas(LL n, LL m, LL Pi, LL Pk)&#123; LL C1 = fac(n, Pi, Pk), C2 = fac(n - m, Pi, Pk), C3 = fac(m, Pi, Pk); LL tim = 0; for(register LL i = n; i; i /= Pi)tim += i / Pi; for(register LL i = n - m; i; i /= Pi)tim -= i / Pi; for(register LL i = m; i; i /= Pi)tim -= i / Pi; return C1 * inv(C2, Pk) % Pk * inv(C3, Pk) % Pk * ksm(Pi, tim, Pk) % Pk;&#125;inline LL calc(LL n, LL m, LL Pi, LL Pk)&#123; LL ans = ExLucas(n, a[0], Pi, Pk); for(register int i = 1; i &lt;= m; i++) ans = ans * ExLucas(s[i], a[i], Pi, Pk) % Pk; return ans;&#125;inline LL China(LL n, LL m, LL P)&#123; LL A = 0, M = P, Pk = 1; for(register LL i = 2; i &lt;= P; i++) if(P % i == 0)&#123; Pk = 1; while(P % i == 0)Pk *= i, P /= i; A = (A + calc(n, m, i, Pk) * (M / Pk) % M * inv(M / Pk, Pk) % M) % M; &#125; return (A + M) % M;&#125;int main()&#123; P = read(); n = read(); m = read(); for(register int i = 1; i &lt;= m; i++) a[0] += (a[i] = read()); for(register int i = m; i &gt;= 1; i--) s[i] = s[i + 1] + a[i]; if(a[0] &gt; n)&#123;cout &lt;&lt; "Impossible"; return 0;&#125; cout &lt;&lt; China(n, m, P); return 0;&#125; 3.ARC59-EキャンディーとN人の子供 / Children and Candies 题目大意 : 幼儿园里有\(n\)个小朋友, 你有\(C\)块糖, 第\(i\)个小朋友一开始有一个兴奋程度\(x, x\in [A_i, B_i]\), 如果这个朋友获得了\(a_i\)块糖, 那么\(Ta\)的兴奋程度会变为\(x^{a_i}\), 定义整个幼儿园的兴奋程度为 \[ \prod_{i = 1}^{n}x^{a_i} \] 要求求出, 对于所有的分糖方案的的整个幼儿园兴奋程度的和 题解 : 我们考虑\(dp\), 定义\(f[i][j]\), 为前\(i\)个小朋友分了 \(j\) 块糖的所有方案的幼儿园兴奋程度的和, 所以很显然有一个这样的转移 : \[ f[i][j] = \sum_{k = 0}^{j} \big(f[i][j - k] \cdot \sum_{v = A[i]}^{B[i]} v^{k}\big) \] 我们发现样的话复杂度是\(O(n^4)\)的, 复杂度很有问题 然后我们观察可以发现\(\sum_{v = A[i]}^{B[i]}v^k\)和\(j\)根本就没有关系, 所以没有必要每次都求一遍, 那么我么可以直接把\(k\)放在第二层枚举, \(j\)丢到最后一层枚举, 这样的话复杂度就成功的降为\(O(n^3)\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 4e2 + 5;const int P = 1e9 + 7;int n, C, A[maxn], B[maxn], mi[maxn][maxn], f[maxn][maxn];int maxv;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int pls(int x, int y)&#123;x += y; return x &gt;= P ? x - P : x;&#125;inline int mul(int x, int y)&#123;LL rnt = 1ll * x * y; return (int)(rnt &gt;= P ? rnt % P : rnt);&#125;int main()&#123; n = read(); C = read(); for(register int i = 1; i &lt;= n; i++)A[i] = read(); for(register int i = 1; i &lt;= n; i++)maxv = max(maxv, B[i] = read()); for(register int i = 1; i &lt;= maxv; i++)&#123; mi[i][0] = 1; for(register int j = 1; j &lt;= C; j++) mi[i][j] = mul(mi[i][j - 1], i); &#125; f[0][0] = 1; for(register int i = 1; i &lt;= n; i++) for(register int k = 0; k &lt;= C; k++)&#123; int res = 0; for(register int j = A[i]; j &lt;= B[i]; j++)res = pls(res, mi[j][k]); for(register int j = k; j &lt;= C; j++) f[i][j] = pls(f[i][j], mul(f[i - 1][j - k], res)); &#125; cout &lt;&lt; f[n][C]; return 0;&#125;/*2 31 11 1*/ 4.ARC60E-高橋君とホテル / Tak and Hotels 题目大意 : 在一条直线有\(n\)个旅馆, 每个旅馆在直线上有坐标, 每个旅馆的坐标为\(x_i\), 你每一步最多走\(L\), 也可以小于\(L\), 现在有\(m\)个询问\((a_i, b_i)\), 询问从\(a_i\)号旅馆到\(b_i\)号旅馆的最少步数 题解 : 我们考虑倍增\(go[i][j]\)表示从第\(i\)个旅馆往前走\(2^j\)步最远可以走到哪个旅馆, 然后就可以直接倍增了 但是有个问题 : \(go[i][0]\)我们怎么预处理, 直接暴力? 但是这样有可能被卡, 所以我们考虑搞一个双指针往后扫, 这样就可以\(O(n)\)预处理了 然后就水过了 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n, L, Q, x[maxn], go[maxn][20];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline void PreGo(int n, int L, int *x)&#123; int pos = 1; for(register int i = 1; i &lt;= n; i++)&#123; while(pos &lt;= n &amp;&amp; x[pos] - x[i] &lt;= L)pos++; go[i][0] = pos - 1; &#125; for(register int j = 1; j &lt;= 19; j++) for(register int i = 1; i &lt;= n; i++) go[i][j] = go[go[i][j - 1]][j - 1];&#125;int main()&#123; n = read(); for(register int i = 1; i &lt;= n; i++)x[i] = read(); L = read(); Q = read(); PreGo(n, L, x); for(register int i = 1; i &lt;= Q; i++)&#123; int a = read(), b = read(), now, ans = 0; if(a &gt; b)swap(a, b); now = a; for(register int k = 19; ~k; k--) if(go[now][k] &lt; b)&#123; now = go[now][k]; ans |= (1 &lt;&lt; k); &#125; printf("%d\n", ans + 1); &#125; return 0;&#125;/*91 3 6 13 15 18 19 29 311041 87 36 78 5*/ 5.ARC60E-すぬけ君の地下鉄旅行 / Snuke's Subway Trip 题目大意 : 现在有一张图, 上面有\(n\)个点, \(m\)条边, 每条边隶属于一个公司, 当你从\(u\)移动到\(v\)时, 经过的这条边\((u, v)\) 隶属的公司和转移到\(u\)的那条边隶属的公司不一样, 你的花费就会加一, 求从\(1\)走到\(n\)的最小花费, 如果可以到达输出花费, 否则输出\(-1\) 题解 : 我们考虑一下最短路的原理, 最短路我们只关心到某个点的最短路, 就算当前距离和以前更新过的答案一样也不用更新, 因为这样对后面的更新没有影响 我们再来考虑一下这道题, 我们考虑记录一下当前最优状态是可能从哪几条边转移过来的, 然后以后的转移基于我们记录的边, 就像这样 : \(S[v]\)表示到\(v\)点的最短距离时, 有可能转移到这个状态的边集, 这时如果我们想从\(u\)点移动到\(v\)点, 如果\((u, v)\)这条边在\(S[v]\)这个集合中出现过了, 那么这次转移的花费就是\(0\), 否则是\(1\), 然后如果\(dis[u] + w &lt; dis[v]\), 我们就清空\(S[v]\), 并加入\((u, v)\)这条边, 如果\(dis[u] + w = dis[v]\)就直接往\(S[v]\)中加一条边就行了 那么这样做为什么是正确的呢? 因为对于某个点无论是什么状态, 它往外转移的边都是相同的, 所以就算某个不优的状态转移时可以更优, 但也只能少\(1\), 这样也不会比当前最优的要优 我们可以用式子说明, 我们设不优的状态为\(old\), 最优状态为\(new\), 我们有\(old - new \geq 1\), 所以我们有 : \[ new + 1 \le old + 0 \] 所以正确性没有问题 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e5 + 5;const int inf = 0x3f3f3f3f;int n, m, head[maxn], cnt, dis[maxn], vis[maxn];struct Graph&#123;int to, nt, C;&#125;e[maxn &lt;&lt; 1];set&lt;int&gt;S[maxn];priority_queue&lt;pair&lt;int, int&gt; &gt;q;inline int read() &#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline void ini(int x, int y, int C) &#123;e[++cnt] = (Graph)&#123;y, head[x], C&#125;; head[x] = cnt;&#125;inline void Dij(int s) &#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); q.push(make_pair(dis[s] = 0, s)); while(!q.empty()) &#123; int now = q.top().second; q.pop(); if(vis[now])continue; vis[now] = 1; for(register int i = head[now]; i; i = e[i].nt) &#123; int v = e[i].to, w; w = S[now].count(e[i].C) ? 0 : 1; if(dis[v] &gt; dis[now] + w) &#123; dis[v] = dis[now] + w; q.push(make_pair(-dis[v], v)); S[v].clear(); S[v].insert(e[i].C); &#125; else if(dis[v] == dis[now] + w) S[v].insert(e[i].C); &#125; &#125;&#125;int main()&#123; n = read(); m = read(); for(register int i = 1; i &lt;= m; i++)&#123; int x = read(), y = read(), C = read(); ini(x, y, C); ini(y, x, C); &#125; Dij(1); cout &lt;&lt; (dis[n] == inf ? -1 : dis[n]); return 0;&#125; 6.ARC58C - こだわり者いろはちゃん / Iroha's Obsession 题目大意 : 求出一个不小于\(n\)的数, 要求其满足以下条件 : 设这个数的各个位的数字的集合为\(S\), 给出一个集合\(D\), (保证集合D当中的元素属于\([0,9]\)) \[ \large{S} \large\cap \large{D} = \varnothing \] 题解 : 考虑直接暴力枚举, 如果符合条件直接输出就好了 代码 : 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2e5 + 5;const int P = 1e9 + 7;int n, k, D[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f; &#125;inline bool check(int x) &#123; while(x) &#123; if(D[x % 10])return false; x /= 10; &#125; return true;&#125;int main()&#123; n = read(); k = read(); for(register int i = 1; i &lt;= k; i++) D[read()] = 1; for(register int i = n; i &lt;= maxn; i++) if(check(i)) &#123;cout &lt;&lt; i; return 0;&#125; return 0;&#125; 7.ARC58D - いろはちゃんとマス目 / Iroha and a Grid 题目大意 : 给你一个\(n \times m\)的矩阵, 你只能往下或者往右走, 问你从左上角走到右下角并且不经过左下角\(H \times W\)的矩阵的所有方案数对\(10^9 + 7\)取膜后的答案 题解 : 我们先考虑一个事实, 如果我们从一个\(N \times M\)的没有任何障碍的矩阵的左上角走到右下角的方案数, 我们可以\(dp\), 但是复杂度不对, 事实上我们这个方案数其实就是 \[ \binom{n + m - 2}{n - 1} \] 其实就是, 我们一共走\(n + m - 2\)步, 纵向走\(n-1\)步, 问你有多少总方案, 然后就可以转化成上面那个东西了 知道上面那个结论以后, 我们再来考虑有障碍物的情况, 如图 : 我们知道从左上角分别走到蓝色区域的第一排的每个格子的方案数, 我们也知道从右下角分别走到蓝色区域第二排的每个格子的方案数, 根据乘法原理答案很显然就是就是 : \[ \sum _{i = B + 1}^{i \le m} \binom {n - H + i - 2}{n - H - 1} \cdot \binom {H + m - i - 1}{H - 1} (mod \ \ 10^9 + 7) \] 代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2e5 + 5;const int P = 1e9 + 7;int n, m, fac[maxn], A, B, ans;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f; &#125;inline int pls(int x, int y) &#123;x += y; return x &gt;= P ? x - P : x;&#125;inline int mul(int x, int y) &#123;LL rnt = 1ll * x * y; return (int)(rnt &gt;= P ? rnt % P : rnt);&#125;inline int ksm(int x, int k) &#123; int cnt = 1; while(k) &#123; if(k &amp; 1) cnt = mul(cnt, x); x = mul(x, x); k &gt;&gt;= 1; &#125; return cnt;&#125;inline int C(int x, int y) &#123; int n = x + y - 2, m = x - 1; if(m &gt; n) return 0; return mul(mul(ksm(fac[n - m], P - 2), ksm(fac[m], P - 2)), fac[n]);&#125;int main()&#123; n = read(); m = read(); fac[0] = 1; for(register int i = 1; i &lt;= n + m; i++) fac[i] = mul(fac[i - 1], i); A = read(); B = read(); for(register int i = B + 1; i &lt;= m; i++) &#123; //cerr &lt;&lt; (n - A) &lt;&lt; " " &lt;&lt; i &lt;&lt; " " &lt;&lt; B &lt;&lt; " " &lt;&lt; m - i + 1 &lt;&lt; endl; ans = pls(ans, mul(C(n - A, i), C(A, m - i + 1))); &#125; cout &lt;&lt; ans; return 0;&#125; 8.ARC58E - 和風いろはちゃん / Iroha and Haiku 题目大意 : 你现在有一个长度为\(N\)的序列(序列中的每个数小于等于\(10\)), 让你求有多少个序列, 存在一个子序列满足这个子序列可以分为三个子序列, 且第一个子序列的和为\(X\), 第二个子序列的和为\(Y\), 第三个子序列的和为\(Z\) 题解 : 首先我先讲一下我一开始想的辣鸡错误方法 我们考虑直接\(dp\), \(h[i][j]\)表示长度为\(i\)的和为\(j\)的序列的方案数, \(g[i]\)表示长度为\(i\)满足题目条件的序列的方案数 \(f[L][i][j]\), 表示长度为\(L\)的序列中只存在从第\(i\)个数开始的一个长度为\(j\)的子序列满足题目中的条件的方案数 那么转移就是 : \[ f[L][i][j] = g[j] \cdot 10^{L - j} - \sum _{l = 1}^{l &lt; i}\sum _{p = 1}^{p \le l} \sum_{v = 1}^{p + v - 1 \le l} f[l][p][v] - \sum _{l = 1}^{l \le L - (i + j - 1)}\sum _{p = 1}^{p \le l} \sum_{v = 1}^{p + v - 1 \le l} f[l][p][v] \] 这个转移就是, 枚举两个区间\([1, i - 1], [L- (i + j - 1)]\), 把这两个区间中所有包含合法序列的方案数都减掉, 但是还是会算重, 为什么呢? 因为如果枚举到左侧的一个长度为\(i - 1\)的区间, 你无法去掉这个区间和\([i, i + j - 1]\)这个区间拼起来的区间中的合法方案数, 所以如果这样搞得话, 根本无法去重 然后, 我就去抄了一波正解 我们还是考虑\(dp\), 如果我们无法直接计算合法的方案数, 那我们就考虑不合法的方案数, 最后直接拿总方案数减去不合法的方案数就好了 设状态\(f[i][S]\)表示前\(i\)个数, 后若干个数加起来不超过\(X+Y+Z\)的状态的不合法的方案数 什么意思呢? 举个栗子吧 : 序列\(1, 2, 3\), 被表示成二进制状态就是\(1 | 100 |100000 = 100101\) 我们知道一个序列的状态为 \[ \sum _{i = 1} ^ {i \le n} (1 &lt;&lt; s[i]) \] \(s[i]\)为这个序列的前缀和 这样表示一个序列的状态有什么好处呢 ? 这样的话这个状态一定会包含其一个子序列的状态, 这样的话我们就可以用这个状态来判别是否合法了 那么转移十分显然 , 设题目中给出的合法方案的状态为 \(S_2\) : \[ f[i][S] = \sum _{k = 1} ^ {k \le 10}f[i - 1][(S &lt;&lt; k) | (1 &lt;&lt; k - 1) \&amp; U] \cdot [(((S&lt;&lt;k) | (1 &lt;&lt; k - 1) \&amp; U) \&amp; S_2) != S_2] \] 我们考虑一下这样转移的正确性 : 显然如果当地前状态包含了题目给出的状态肯定是无法转移的, 如果当前不包含题目中所给出的状态, 那么转移一定是合法的, 因为每一次转移都是基于当前状态不包含合法状态, 所以最后正确性是一定没有问题的 代码 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 45;const int P = 1e9 + 7;int n, x, y, z, f[maxn][1 &lt;&lt; 18];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f; &#125;inline int pls(int x, int y) &#123;x += y; return x &gt;= P ? x - P : x;&#125;inline int dec(int x, int y) &#123;x -= y; return x &lt; 0 ? x + P : x;&#125;inline int mul(int x, int y) &#123;LL rnt = 1ll * x * y; return (int)(rnt &gt;= P ? rnt % P : rnt);&#125;inline int ksm(int x, int k) &#123; int cnt = 1; while(k) &#123; if(k &amp; 1) cnt = mul(cnt, x); x = mul(x, x); k &gt;&gt;= 1; &#125; return cnt;&#125;int main()&#123; n = read(); x = read(); y = read(); z = read(); int ans = ksm(10, n); int tot = (1 &lt;&lt; x - 1) | (1 &lt;&lt; x + y - 1) | (1 &lt;&lt; x + y + z - 1); int S = (1 &lt;&lt; x + y + z); f[0][0] = 1; for(register int i = 1; i &lt;= n; i++) for(int S2 = 0; S2 &lt; S; S2++) for(register int k = 1; k &lt;= 10; k++) &#123; int cur = ((S2 &lt;&lt; k) | (1 &lt;&lt; k - 1)) &amp; (S - 1); if((cur &amp; tot) != tot) f[i][cur] = pls(f[i][cur], f[i - 1][S2]); &#125; for(register int S2 = 0; S2 &lt; S; S2++) &#123; ans = dec(ans, f[n][S2]); //if((S2 &amp; tot) == tot) cout &lt;&lt; f[n][S2] &lt;&lt; endl; &#125; cout &lt;&lt; ans; return 0;&#125; 9.ARC58F - 文字列大好きいろはちゃん / Iroha Loves Strings 题目大意 : 给你\(N\)个字符串, 现在你可以从其中任意选出几个, 要求拼成一个长度为\(K\)的字符串, 要求输出字典序最小的那一个, 拼接顺序要按照题目给出的顺序拼接 \[ N \in [1, 2000], \sum |s_i| \le 10^6, K \le 10^4 \] 题解 : 我们先考虑一下暴力\(dp\)直接背包, 设状态\(f[i][j]\)为前\(i\)个字符串中拼成长度为\(j\)的最小字典序的字符串, 由于每一次转移为\(|s_i|\), 这样的话复杂度是\(O(N\cdot K \cdot \sum|s_i|)\)的, 非常的不正确 我们考虑一下这样\(dp\)的原因是什么, 因为我们无法保证你当前最优的串, 是否能再后续的字符串中拼接到\(K\)的长度, 所以我们考虑保存每一种可能的长度的最优解, 但是如果我们知道是否能够拼成的话, 这样的保存就变得非常没有必要了 所以我们考虑先利用\(dp\)的思想预处理出来一个数组\(Rm[i][j]\), 表示用\(i \sim N\)的字符串是否能够拼成长度为\(j\)的字符串, 然后每次我们只用保存一个字符串就可以了, 并且我们每次更新一下这个字符串的断点, 每次考虑从这个位置接上当前串, 看是否能够组成更优的串, 以此来做到更新答案的目的 但是还有一个很重要的问题就是, 如何快速比较字典序, 如果我们直接比较的话复杂度肯定是\(O(|s_i|)\)的, 我们考虑把比较字典序的问题转化为找\(LCP\)的问题, 最后直接比较\(LCP\)的后一位就好了, 这里我们可以直接\(Hash\)一下,每次二分一个位置, 比较一下就好了, 这样我们就成功的把比较的复杂度降至\(O(log|s_i|)\)了 至此, 题目我们已经完成了一大半了, 可是还有一个很重要的问题就是, 如果当前串真包含一个颗可以拼接而成的串的话, 我们要额外的更新一下断点, 这样才可以保证最后答案的正确性 \(PS:\) 我说的好像头头是道, 但是这道题我调了一个星期还是\(WA\)了\(5\)个点, 求神犇查错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 2e3 + 505;const int maxm = 1e4 + 505;const ull seed = 233;int n, k, len[maxn];ull Hash[maxm], cur[maxm], fac[maxn * 505];char ex[maxm];string s[maxn], st[maxn];bool Rm[maxn][maxm], ok[2][maxm];inline int read() &#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(isdigit(ch)) &#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int checkit(string &amp;st, string &amp;s, int pos, int j) &#123; int l = 1, r = min(pos, j) + s.size(), R = 0, mid = (l + r) / 2; R = r; int siz = s.size(), ans = 0, ch0, ch1; while(l &lt;= r) &#123; mid = (l + r) / 2; ull H0 = 0, H1 = 0; if(mid &lt;= pos) H0 = cur[mid]; else H0 = cur[pos] * fac[mid - pos] + Hash[mid - pos]; if(mid &lt;= j) H1 = cur[mid]; else H1 = cur[j] * fac[mid - j] + Hash[mid - j]; if(H0 == H1) l = mid + 1, ans = mid; else r = mid - 1; &#125; if(ans == R) return j &gt; pos ? j : pos; else &#123; if(ans &gt;= pos) ch0 = s[ans - pos]; else ch0 = st[ans]; if(ans &gt;= j) ch1 = s[ans - j]; else ch1 = st[ans]; return ch0 &gt; ch1 ? j : pos; &#125;&#125;inline string checkagain(string &amp;st, string &amp;now, string &amp;s, int pos) &#123; int l = 1, r = min(now.size(), st.size()), R = 0, mid = (l + r) / 2; R = r; int siz = s.size(), ans = 0, ch0, ch1; while(l &lt;= r) &#123; mid = (l + r) / 2; ull H0 = 0, H1 = 0; H0 = cur[mid]; if(mid &lt;= pos) H1 = cur[mid]; else H1 = cur[pos] * fac[mid - pos] + Hash[mid - pos]; if(H0 == H1) l = mid + 1, ans = mid; else r = mid - 1; &#125; if(ans == R) &#123; if(st.size() &gt; now.size()) return st; else return now; &#125; else &#123; ch0 = now[ans]; ch1 = st[ans]; if(ch0 &gt; ch1) return st; else return now; &#125;&#125;int main() &#123; freopen("in", "r", stdin); freopen("MY", "w", stdout); n = read(); k = read(); fac[0] = 1; for(register int i = 1; i &lt;= maxn * 500; i++) fac[i] = fac[i - 1] * seed; for(register int i = 1; i &lt;= n; i++) &#123; scanf("%s", ex); s[i] = ex; &#125; Rm[n + 1][0] = 1; for(register int i = n; i &gt;= 1; i--) for(register int j = 0; j &lt;= k; j++) &#123; if(j &gt;= s[i].size()) Rm[i][j] |= Rm[i + 1][j - s[i].size()]; Rm[i][j] |= Rm[i + 1][j]; &#125; if(Rm[2][k - s[1].size()]) &#123; ok[0][1] = 1; st[1] = s[1]; &#125; for(register int i = 2; i &lt;= n; i++) &#123; int t = i &amp; 1, t0 = t ^ 1, p = -1; memset(ok[t0], 0, sizeof(ok[t0])); cur[0] = Hash[0] = 0; for(register int j = 1; j &lt;= st[i - 1].size(); j++) cur[j] = cur[j - 1] * seed + st[i - 1][j - 1]; for(register int j = 1; j &lt;= s[i].size(); j++) Hash[j] = Hash[j - 1] * seed + s[i][j - 1]; for(register int j = 1; j &lt;= st[i - 1].size() + 1; j++) &#123; if(!Rm[i + 1][k - (j + s[i].size() - 1)] || !(ok[t][j] || j &gt; st[i - 1].size())) continue; if(p == -1) p = j; else p = checkit(st[i - 1], s[i], p - 1, j - 1) + 1; &#125; if(p != -1) st[i] = st[i - 1].substr(0, p - 1) + s[i]; else st[i] = st[i - 1]; if(Rm[i + 1][k - st[i - 1].size()]) st[i] = checkagain(st[i - 1], st[i], s[i], p - 1); if(st[i] == st[i - 1]) p = st[i].size() + 1; for(register int j = 1; j &lt;= k; j++) &#123; int o = j + s[i].size() - 1; if(o &gt; st[i].size()) break; if(!Rm[i + 1][k - o] || !ok[t][j]) continue; ull H0 = 0, H1 = 0; if(o &gt; p - 1) H0 = cur[p - 1] * fac[o - (p - 1)] + Hash[o - (p - 1)]; else H0 = cur[o]; H1 = cur[j - 1] * fac[s[i].size()] + Hash[s[i].size()]; if(H0 == H1) ok[t0][o + 1] = 1; &#125; ok[t0][p] = 1; for(register int j = 1; j &lt;= k; j++) &#123; if(j &gt; st[i].size()) continue; if(!Rm[i + 1][k - (j - 1)] || !ok[t][j]) continue; ull H0 = 0, H1 = 0; H0 = cur[j - 1]; if(j &gt; p - 1) H1 = cur[p - 1] * fac[j - p] + Hash[j - p]; else H1 = cur[j - 1]; if(H0 == H1) ok[t0][j] = 1; &#125; /*cerr &lt;&lt; "case" &lt;&lt; i &lt;&lt; ": " &lt;&lt; endl; cerr &lt;&lt; st[i] &lt;&lt; endl; for(register int j = 1; j &lt;= k; j++) cerr &lt;&lt; ok[t0][j] &lt;&lt; " "; cerr &lt;&lt; "\n\n"; */&#125; cout &lt;&lt; st[n]; return 0;&#125;/**/ 10.NOI.AC 模拟赛R2 T1 palindrome 题目大意 : 要你求一个最长回文字串的切分, 我们平常定义回文串是比较开头和结尾的字符, 这道题里面就是将一个子串看成一个字符来比较, 详情见题面 题解 : 考虑直接\(Hash\)头一个指针, 尾一个指针, 往中间扫, 一匹配到相同的就直接\(ans += 2\), 最后判一下\(ans\)是否要加一就行了, 水水水 代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 1e6 + 5;const int seed0 = 233;const int seed1 = 277;const ull P = 998244353;int T, n, ans;ull fac0[maxn], fac1[maxn];char s[maxn];inline int read() &#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(isdigit(ch)) &#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;struct Hash &#123; ull hash0, hash1; Hash (ull H0 = 0, ull H1 = 0) &#123;hash0 = H0; hash1 = H1;&#125; inline void mul(ull s, int k) &#123; hash0 = hash0 + s * fac0[k]; hash1 = (hash1 + s * fac1[k] % P) % P; &#125; inline void push(ull s) &#123; hash0 = hash0 * seed0 + s; hash1 = (hash1 * seed1 % P + s) % P; &#125; inline void clear() &#123;hash0 = hash1 = 0;&#125; bool operator == (const Hash &amp;t) const &#123;return hash0 == t.hash0 &amp;&amp; hash1 == t.hash1;&#125;&#125;t0, t1;int main() &#123;#ifndef ONLINE_JUDGE freopen("palindrome.in", "r", stdin); freopen("palindrome.out", "w", stdout);#endif T = read(); fac0[0] = fac1[0] = 1; for(register int i = 1; i &lt; maxn; i++) fac0[i] = fac0[i - 1] * seed0, fac1[i] = fac1[i - 1] * seed1 % P; while(T--) &#123; scanf("%s", s + 1); n = strlen(s + 1); ans = 0; t0.clear(); t1.clear(); int l = 1, r = n, L = 1, R = n; while(l &lt; r) &#123; t0.push(s[l]); t1.mul(s[r], R - r); if(t0 == t1) &#123; ans += 2; t0.clear(); t1.clear(); L = l + 1; R = r - 1; &#125; l++; r--; &#125; printf("%d\n", ans + (!(t0 == t1) || (n &amp; 1))); &#125; return 0;&#125; /*1abananab*/ 11.NOA.AC 模拟赛R2 T2 string 题目大意 : 你有一个只由\(A,B,C,D\)组成的长度为\(N\)的字符串, 你有\(M\)种魔法, 每次可以把一个字符串\(S_i\)变为\(S_i&#39;\) 并且你可一交换一个字符串中的相邻的两个字符, 问你最多可以变成多少种不同的字符串 题解 : 不要被题目所迷惑了, 题目中告诉我们可以交换一个字符串中相邻的两个字符, 也就是间接的告诉我, 我们不用考虑, 这个字符串的具体形态是什么, 只用考虑这个字符串中有多少个\(A\), 多少个\(B\), 多少个\(C\), 多少个\(D\), 就行了 那么我们可以将题目中给出的\(M\)种魔法看成从一种状态向另一种状态的转移, 我们可以直接把每一种状态看成一个点, 每个点的权值是当前状态可以组成不同的字符串的方案数, 每一种魔法看成一种状态向另一种状态的连边, 并且是单向边, 最后我们把图建出来以后, 直接缩一下点, 然后在\(DAG\)图上\(dp\)一下就好了 最后对于一开始每种状态的权值, 我们也可\(dp\)一下就可以了 设状态\(g[i][j][k][v]\)表示长度为\(i\)的字符串, 有\(j\)个\(A\), \(k\)个\(B\), \(v\)个\(C\)的方案数, 转移很显然就是 : \[ g[i][j][k][v] = g[i - 1][j - 1][k][v] \cdot [j &gt; 1] + g[i - 1][j][k - 1] \cdot [k &gt; 1] + g[i - 1][j][k][v - 1] \cdot [v &gt; 1] + g[i - 1][j][k][v] \cdot [i - j - k - v &gt; 1] \] 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 55;const int maxs = 2e4 + 5e3 + 5;const int maxm = 1e6 + 5;int n, m, con, cal[maxn &lt;&lt; 1][2][1 &lt;&lt; 8], in[maxn], bcnt;int P[maxn][maxn][maxn], st[maxs], top, be[maxs], becnt, dfn[maxs], low[maxs];__int128 g[maxn][maxn][maxn][maxn], w[maxs], ans, f[maxs];bool vis0[maxs], vis1[maxs], instack[maxs];char s0[maxn], s1[maxn], putit[maxs];struct Node &#123;int A, B, C, D;&#125; t[maxs];struct Graph &#123; int head[maxs], cnt = 1; struct node &#123;int to, nt;&#125; e[maxm]; inline void ini(int x, int y) &#123;e[++cnt] = (node)&#123;y, head[x]&#125;; head[x] = cnt;&#125;&#125;G, E;inline int read() &#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch)) &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(isdigit(ch)) &#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline __int128 getit(int id) &#123; int A = t[id].A, B = t[id].B, C = t[id].C; return g[n][A][B][C];&#125;inline void Tarjan(int now) &#123; dfn[now] = low[now] = ++dfn[0]; instack[st[++top] = now] = true; for(register int i = G.head[now]; i; i = G.e[i].nt) &#123; int v = G.e[i].to; if(!dfn[v]) &#123; Tarjan(v); low[now] = min(low[now], low[v]); &#125; else if(instack[v]) low[now] = min(low[now], low[v]); &#125; if(dfn[now] == low[now]) &#123; bcnt++; while(now != st[top]) &#123; be[st[top]] = bcnt; w[bcnt] += getit(st[top]); instack[st[top--]] = false; &#125; be[st[top]] = bcnt; w[bcnt] += getit(st[top]); instack[st[top--]] = false; &#125;&#125;inline void rebuild() &#123; for(register int now = 1; now &lt;= con; now++) for(register int i = G.head[now]; i; i = G.e[i].nt) &#123; int v = G.e[i].to; if(be[now] != be[v]) E.ini(be[now], be[v]), in[be[v]]++; &#125;&#125;inline void write(__int128 x) &#123; int len = 0; while(x) &#123; putit[++len] = x % 10 + '0'; x /= 10; &#125; for(register int i = len; i &gt;= 1; i--)putchar(putit[i]);&#125;inline void Topsort() &#123; queue&lt;int&gt;q; while(!q.empty()) q.pop(); for(register int i = 1; i &lt;= bcnt; i++) if(in[i] == 0) q.push(i), f[i] = w[i]; while(!q.empty()) &#123; int now = q.front(); q.pop(); ans = max(ans, f[now]); for(register int i = E.head[now]; i; i = E.e[i].nt) &#123; int v = E.e[i].to; f[v] = max(f[v], f[now] + w[v]); in[v]--; if(in[v] == 0)q.push(v); &#125; &#125;&#125;int main() &#123; n = read(); m = read(); for(register int i = 0; i &lt;= n; i++) for(register int j = 0; i + j &lt;= n; j++) for(register int k = 0; i + j + k &lt;= n; k++) &#123; t[++con] = (Node) &#123;i, j, k, n - i - j - k&#125;; P[i][j][k] = con; &#125; /*cerr &lt;&lt; endl; for(register int i = 1; i &lt;= con; i++) cerr &lt;&lt; "case " &lt;&lt; i &lt;&lt; ": A = " &lt;&lt; t[i].A &lt;&lt; " B = " &lt;&lt; t[i].B &lt;&lt; " C = " &lt;&lt; t[i].C &lt;&lt; " D = " &lt;&lt; t[i].D &lt;&lt; endl; */ g[0][0][0][0] = 1; for(register int i = 1; i &lt;= n; i++) for(register int j = 0; j &lt;= i; j++) for(register int k = 0; j + k &lt;= i; k++) for(register int v = 0; j + k + v &lt;= i; v++) &#123; if(j &gt; 0) g[i][j][k][v] += g[i - 1][j - 1][k][v]; if(k &gt; 0) g[i][j][k][v] += g[i - 1][j][k - 1][v]; if(v &gt; 0) g[i][j][k][v] += g[i - 1][j][k][v - 1]; if(i - j - k - v &gt; 0) g[i][j][k][v] += g[i - 1][j][k][v]; &#125; //cerr &lt;&lt; g[6][3][1][1] &lt;&lt; endl; //write(g[6][3][1][1]); cerr &lt;&lt; endl; for(register int i = 1; i &lt;= m; i++) &#123; int len = 0, t0 = 0, t1 = 0; scanf("%s%s", s0 + 1, s1 + 1); len = strlen(s0 + 1); for(register int j = 1; j &lt;= len; j++) &#123; cal[i][0][s0[j]]++; cal[i][1][s1[j]]++; &#125; &#125; for(register int i = 1; i &lt;= con; i++) &#123; //cerr &lt;&lt; "#case : " &lt;&lt; i &lt;&lt; endl; for(register int j = 1; j &lt;= m; j++) &#123; int A0 = cal[j][0]['A'], B0 = cal[j][0]['B']; int C0 = cal[j][0]['C'], D0 = cal[j][0]['D']; int A1 = cal[j][1]['A'], B1 = cal[j][1]['B']; int C1 = cal[j][1]['C'], D1 = cal[j][1]['D']; if(A0 == A1 &amp;&amp; B0 == B1 &amp;&amp; C0 == C1)continue; if(t[i].A &gt;= A0 &amp;&amp; t[i].B &gt;= B0 &amp;&amp; t[i].C &gt;= C0 &amp;&amp; t[i].D &gt;= D0) &#123; G.ini(i, P[t[i].A - A0 + A1][t[i].B - B0 + B1][t[i].C - C0 + C1]); //cerr &lt;&lt; i &lt;&lt; " " &lt;&lt; P[t[i].A - A0 + A1][t[i].B - B0 + B1][t[i].C - C0 + C1] &lt;&lt; endl; &#125; &#125; //cerr &lt;&lt; endl; &#125; for(register int i = 1; i &lt;= con; i++) if(!dfn[i]) Tarjan(i); /*for(register int i = 1; i &lt;= bcnt; i++) &#123; cerr &lt;&lt; "w[" &lt;&lt; i &lt;&lt; "] = "; write(w[i]); cerr &lt;&lt; endl; &#125; cerr &lt;&lt; endl; for(register int i = 1; i &lt;= con; i++) &#123; cerr &lt;&lt; "g[" &lt;&lt; i &lt;&lt; "] = "; write(getit(i)); cerr &lt;&lt; endl; &#125;*/ rebuild(); Topsort(); write(ans); return 0;&#125; 12.BZOJ1027合金 题目大意 : 给你\(N\)个点, 再给你\(M\)个点, 要求从\(M\)个点中选出若干个点使得这些点中的凸包能够包含\(N\)个点所构成的凸包, 要求最小化选出的点集的大小 题解 : 考虑枚举一个点对, 如果所有的需求点都在这两个点所连成的线段上或在直线的上方, 连正向边 如果所有的需求点都在这两个点所连成的线段上或在直线的下方, 连反向边 最后跑一遍\(Floyd\), 答案就是 \[ min \{ dis[i][i]\} \] 代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5e2 + 5;const int inf = 0x3f3f3f3f;const double eps = 1e-13;int n, m, dis[maxn][maxn], ans = inf;double x;struct Vector &#123; double x, y; Vector (double X = 0, double Y = 0) &#123;x = X; y = Y;&#125; Vector operator + (const Vector &amp;t) const &#123;return Vector(x + t.x, y + t.y);&#125; Vector operator - (const Vector &amp;t) const &#123;return Vector(x - t.x, y - t.y);&#125; double operator * (const Vector &amp;t) const &#123;return x * t.x + y * t.y;&#125; double operator ^ (const Vector &amp;t) const &#123;return x * t.y - y * t.x;&#125; bool operator &lt; (const Vector &amp;t) const &#123;return x &lt; t.x;&#125; bool operator &lt;= (const Vector &amp;t) const &#123;return x &lt;= t.x;&#125;&#125;Ha[maxn], Ne[maxn];inline void judge(int x, int y) &#123; int H0 = 0, H1 = 0; for(register int i = 1; i &lt;= m; i++) &#123; double getit = (Ha[x] - Ha[y]) ^ (Ha[x] - Ne[i]); bool is = Ha[x] &lt;= Ne[i] &amp;&amp; Ne[i] &lt;= Ha[y]; H0 += (getit &lt; -eps || (fabs(getit) &lt; eps &amp;&amp; is)); H1 += (getit &gt; eps || (fabs(getit) &lt; eps &amp;&amp; is)); &#125; if(H0 == m) dis[x][y] = 1; if(H1 == m) dis[y][x] = 1; //if(dis[x][y] == 1) cerr &lt;&lt; x &lt;&lt; "--&gt;" &lt;&lt; y &lt;&lt; endl; //if(dis[y][x] == 1) cerr &lt;&lt; y &lt;&lt; "--&gt;" &lt;&lt; x &lt;&lt; endl; //cerr &lt;&lt; endl;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(register int i = 1; i &lt;= n; i++) scanf("%lf%lf%lf", &amp;Ha[i].x, &amp;Ha[i].y, &amp;x); for(register int i = 1; i &lt;= m; i++) scanf("%lf%lf%lf", &amp;Ne[i].x, &amp;Ne[i].y, &amp;x); memset(dis, 0x3f, sizeof(dis)); for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) judge(i, j); for(register int k = 1; k &lt;= n; k++) for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= n; j++) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); for(register int i = 1; i &lt;= n; i++) ans = min(ans, dis[i][i]); cout &lt;&lt; (ans == inf ? -1 : ans); return 0;&#125;]]></content>
      <categories>
        <category>OI刷题记录</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>组合数学</tag>
        <tag>CRT</tag>
        <tag>Exgcd</tag>
        <tag>ExLucas</tag>
        <tag>倍增</tag>
        <tag>计算几何</tag>
        <tag>Lucas</tag>
        <tag>费马小定理</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
        <tag>状压DP</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理学习笔记]]></title>
    <url>%2F2018%2F09%2F03%2FCRT%2F</url>
    <content type="text"><![CDATA[中国剩余定理 有一组膜方程, 要求求出最小的\(x\) \[ \begin{cases}x = a_1(mod\ \ m_1) \\ x = a_2(mod \ \ m_2)\\ x = a_3(mod \ \ m_3)\\ .......... \\ x = a_n (mod \ \ m_n)\end{cases} \] \(m_i\)两两互质时 我们引入中国剩余定理 定义\(M = \prod m_i\), 相当于要求我们构造出一个\(A = x (mod \ \ M)\) 定义\(M_i = \frac {M}{m_i}\), \(M_i^{-1}\)为\(M_i\)在膜\(M\)意义下的逆元, 然后我们有下列等式: \[ a_i \cdot M_i \cdot M_i^{-1} = a_i(mod \ \ m_i)\\ a_i \cdot M_i \cdot M_i^{-1} = 0(mod \ \ M_i) \] 我们可以构造出一个最小解\(A = \sum a_i \cdot M_i \cdot M_i^{-1} (mod \ \ M)\) \(PS\) : 这里求逆元必须要用\(Exgcd\), 因为不保证\(m_i\)为质数, 只保证\(M_i\)与\(m_i\)互质 证明 : 不会, 待填坑...... 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stc++.h&gt;using namesapce std;typedef long long LL;const int maxn = 1e5 + 5;LL n, m[maxn], a[maxn];inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(b == 0)&#123;x = 1; y = 0; return a;&#125; LL x0 = 0, y0 = 0; LL d = exgcd(b, a % b, y0, x0); x = x0; y = y0 - ((a / b) * x0); return d;&#125;inline LL china(LL *a, LL *m, LL n)&#123; LL M = 1, ans = 0, tmp; for(register int i = 1; i &lt;= n; i++)M *= m[i]; for(register int i = 1; i &lt;= n; i++)&#123; int Mi = M / m[i], inv; exgcd(Mi, m[i], inv, tmp); ans = (ans + Mi * inv * a[i]) % M; &#125; return (M + ans % M) % M;&#125;int main()&#123; n = read(); for(register int i = 1; i &lt;= n; i++) a[i] = read(), m[i] = read(); cout &lt;&lt; china(a, m, n); return 0;&#125; \(m_i\)为任意数 我们引入拓展中国剩余定理, 比如对于一组膜方程 : \[ \begin{cases} x = a_1 (mod \ \ m_1)\\ x = a_2(mod \ \ m_2)\end{cases} \] 我们将式子转换一下 \[ x = a_1 + m_1 \cdot y_1, x = a_2 + m_2 \cdot y_2 \] \[ x = a_1 + m_1 \cdot y_1 = a_2 + m_2 \cdot y_2 \] \[ a_1 - a_2 = m_2 \cdot y_2 - m_1 \cdot y_1 \] 然后我们设\(d = gcd(m_1, m_2)\), 并使得\(m_1 \cdot x + m_2 \cdot y = d\), 显然如果\(d \not\mid (a_1 - a_2)\)无解, 否则就是有解 然后使得\(y_1 = \frac {a_1 - a_2}{d} \cdot x, y_2 = \frac {a_1 - a_2}{d} \cdot y\) \[ A = a_1 + m_1 \cdot y_1 \] 我们就得到了一个合法解, \(x = A(mod \ \ lcm(m_1, m_2))\) 如果膜方程有很多的话, 就依次合并就好了 代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL n, m[maxn], a[maxn];inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if(b == 0)&#123;x = 1; y = 0; return a;&#125; LL x0 = 0, y0 = 0; LL d = exgcd(b, a % b, y0, x0); x = x0; y = y0 - ((a / b) * x0); return d;&#125;inline LL mul(LL x, LL y, LL mod)&#123; x %= mod; y %= mod; return (x * y - (LL)(((long double)x * y + 0.5) / mod) * mod) % mod;&#125;inline LL exchina(LL *a, LL *m, LL n)&#123; LL A = a[1], M = m[1], t, d, x, y; for(register int i = 2; i &lt;= n; i++)&#123; d = exgcd(M, m[i], x, y); if((a[i] - A) % d != 0)return -1; t = m[i] / d; x = mul(x, (a[i] - A) / d, t); //x *= ((a[i] - A) / d); //x = (t + x % t) % t; A = (mul(M, x, M * t) + A) % (M * t); M *= t; A %= M; &#125; return (A % M + M) % M;&#125;int main()&#123; n = read(); for(register int i = 1; i &lt;= n; i++) m[i] = read(), a[i] = read(); cout &lt;&lt; (exchina(a, m, n)); return 0;&#125; 例题讲解 1.BZOJ5418屠龙勇士 题目大意 : 给你一组以下形式的膜方程, 并让你求出最小解 \[ w_i \cdot x = a_i (mod \ \ p_i) \] 我们还是考虑转换一下式子 : \[ w_i \cdot x_i + p_i \cdot y_i = a_i \] 再考虑直接用\(Exgcd\)求出\(w_i \cdot a + p_i \cdot b = gcd(w_i, p_i) = d\), 显然如果\(d \not\mid a_i\)无解, 否则 \[ x = a + k \cdot \frac{p_i}{d} \] 这样我们将膜方程转化为了 : \[ \begin{cases} x = \frac{a_1}{gcd(w_1, p_1)} (mod \ \ \frac{p_1}{gcd(w_1, p_1)})\\ x = \frac{a_2}{gcd(w_2, p_2)} (mod \ \ \frac{p_2}{gcd(w_2, p_2)})\\ ..........\\ x = \frac{a_n}{gcd(w_n, p_n)} (mod \ \ \frac{p_n}{gcd(w_n, p_n)})\\ \end{cases} \] 这样我们就可以愉悦的套上\(ExCRT\)的模板了 但是上面我们所讨论的都是基于\(a_i \leq p_i\)的, 但是如果不保证这个条件的话就会出一些问题, 因为有可能我们根本就没有把血量杀到小于等于零但是在膜\(p_i\)的意义下血量就是零了, 所以这个不是完全正确的, 但是我们又发现所有不满足\(a_i \leq p_i\)的测试点都满足\(p_i = 1\), 所以对于这种情况答案就是 : \[ max\{\lceil \frac{a_i}{w_i} \rceil\} \] 最后关于选剑的问题我们直接用\(multiset\)维护一下就好了, 具体如下 : 先在\(multiset\)里面\(upper\_bound\)一下, 如果这个迭代器为\(begin()\)那么这个答案就是这个迭代器所代表的值, 否则就把这个迭代器减减一下, 就是答案了 Summary 水水水 咕咕咕]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>CRT</tag>
        <tag>Exgcd</tag>
        <tag>ExCRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Streaming#5模拟赛]]></title>
    <url>%2F2018%2F09%2F02%2F20180902%2F</url>
    <content type="text"><![CDATA[Streaming#5 题解报告 T1.珠 题目大意 : 给你一个长度为\(n\)的数字环, 你可顺时针或者逆时针选择一个子序列, 满足子序列的以\(2\)开头, 后面的数字都是\(3\), 求最长子序列 题解 : 我们考虑对于每一个数字为\(2\)的位置向左边和右边二分一个位置, 使得这个位置到数字\(2\)中间全是\(3\), 所以我们必须得先处理处两个数组\(preL, preR\), 表示从一个为\(3\)的位置向左向右全部都是\(3\)的结束位置, 这样就可以二分了, 特别的如果你向右边二分出的位置为这个序列的末尾, 那你必须从这个序列的开头再次二分一个位置, 因为这个是一个环, 头尾可以相接 复杂度为\(O(nlogn)\) 代码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2e5 + 5;const int inf = 1e9 + 5;int posR[maxn], posL[maxn], ans, L, R, n;char s[maxn];inline int binaryR(int l, int r, int i)&#123; int mid = (l + r) / 2, ans = l - 1; while(l &lt;= r)&#123; mid = (l + r) / 2; if(posR[mid] == i)l = mid + 1, ans = mid; else r = mid - 1; &#125; return ans;&#125;inline int binaryL(int l, int r, int i)&#123; int mid = (l + r) / 2, ans = r + 1; while(l &lt;= r)&#123; mid = (l + r) / 2; if(posL[mid] == i)r = mid - 1, ans = mid; else l = mid + 1; &#125; return ans;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("beads.in", "r", stdin); freopen("beads.out", "w", stdout);#endif scanf("%s", s + 1); n = strlen(s + 1); for(register int i = 1; i &lt;= n; i++) if(s[i] == '3')posR[i] = (s[i - 1] == s[i]) ? posR[i - 1] : i; else posR[i] = inf; for(register int i = n; i &gt;= 1; i--) if(s[i] == '3')posL[i] = (s[i + 1] == s[i]) ? posL[i + 1] : i; else posL[i] = -inf; for(register int i = 1; i &lt;= n; i++)&#123; if(s[i] != '2')continue; R = binaryR(i + 1, n, i + 1), L = binaryR(1, i - 1, 1); ans = max(ans, R - i + 1 + L * (R == n)); R = binaryL(i + 1, n, n), L = binaryL(1, i - 1, i - 1); ans = max(ans, i - L + 1 + (n - R + 1) * (L == 1)); &#125; if(ans == 0)puts("TvT"); else &#123; putchar('2'); for(register int i = 1; i &lt; ans; i++)putchar('3'); &#125; return 0;&#125;/*323333233232333333332233233*/ T2.免农 题目大意 : 一开始你有两个免子, 下一个时刻, 你的免子会变成当前时刻的两倍, 然后我们会将这些免子分为若干组, \(k\)个为一组, 特别的如果存在一组, 这一组里只有一个免子, 那么这个免子就会死去, 求\(n\)时刻时免子的个数对\(p\)取余的结果 题解 : 考虑如果\(k\)为偶数的话, 是不会存在单个免子为一组的, 所以最后的答案就是\(2^{n + 1} \% p\) 如果\(k\)为奇数的话, 当\(2^{q} \% k == 1\)的话那么在\(q\)时刻之后, 就不会有免子再会落单了, 并且可以证明在\(k\)个时刻以内, 一定存在一个时刻\(t\), 使得\(2^t \% k == 1\), 所以直接模拟就好了 复杂度\(O(min(k, n))\) 代码 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL n, k, p, now, ans;inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL ksm(LL x, LL k)&#123; LL cnt = 1; while(k)&#123; if(k &amp; 1)cnt = cnt * x % p; x = x * x % p; k &gt;&gt;= 1; &#125; return cnt;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("rabit.in", "r", stdin); freopen("rabit.out", "w", stdout);#endif n = read(); k = read(); p = read(); now = 2 % k; ans = 2; if(!(k &amp; 1))&#123;cout &lt;&lt; ans * ksm(2, n) % p; return 0;&#125; while(now != 1 &amp;&amp; n &gt; 0)&#123; now = 2 * now % k; ans = 2 * ans % p; n--; &#125; if(now == 1)ans--; cout &lt;&lt; (ans + p) % p * ksm(2, n) % p; return 0;&#125;/*6 7 10086*/ T3.高维网络 题目大意 : 现在有一个\(d\)维空间, 起始坐标为\(A(0, 0, ...., 0)\), 结束坐标为\(B(a_1, a_2, ...., a_d)\), 现在有\(p\)个坐标上设有障碍, 并且每一步只能在某一个维度上走一步, 也就是说只能这样转移 : \[ (0, 0, ...., 0) -&gt; (1, 0, ...., 0) or (0, 0,...., 0) -&gt; (0, 1, ...., 0) \] 求从起点走到终点不经过障碍有多少种方案, 输出方案数对\(P\)取余后的结果 题解 : 我们先考虑没有障碍的情况, 从\(x(s_1, s_2, ...., s_d)\)移动到\(y(t_1, t_2, ...., t_d)\)有多少种方案, 首先我们设数组\(tmp_i = t_i - s_i\), 其后缀和为\(S\), 那么我们一定会走\(\sum_{i = 1}^{d}tmp_i\)步, 前\(tmp_1\)步我们可以任意分配就有\(C_{S_1}^{tmp_1}\)种方案, 然后我们依次分配步数就可以知道方案数为 : \[ Paths(x, y) = \prod_{i = 1} ^ {i \leq d} C_{S_i}^{tmp_i} \] 然后如果直接容斥的话复杂度为\(O(2^p \cdot d \cdot logP)\), 实测可以获得\(80\)分的好成绩 我们现在再考虑\(dp\), \(f[i]\)表示从起点到第\(i\)个障碍点并且不经过任何障碍点的方案数, 不难得出转移方程为 : \[ f[i] = Paths(A, i) - \sum_{i \ne j} f[j] * Paths(j, i) \] \(PS\) : 注意\(Paths(x, y)\)有方向性, 表示从\(x\)转移到\(y\)可以经过任意障碍的方案数 并且这个\(dp\) 的转移顺序必需是从最靠近起点\(A\)的障碍点开始转移, 不然会有问题 \(Update\) : 我们来考虑一下这个\(dp\)的正确性, 我们可能会想这样\(dp\)会不会减掉一些重复的路径, 比如说有三个点\(i, j, k\), \(i\)可以到达\(j\), \(j\)可以到达\(k\), 在转移的时候我们会将 \[ f[i] * Paths(i, k) \&amp; \&amp; f[j] * Paths(j, k) \] 都减掉, 这样会不会有问题呢? 实际上是不会的, 我们注意到\(f[i]\)的定义是指从\(A\)到\(i\)号障碍点不经过任何其他障碍的路径方案数, 所以\(f[j]\)中的方案数是不包括\(f[i] * Paths(i, j)\)的, 所以这样\(dp\)的正确性是有保障的, 最终复杂度为\(O(p ^ 2 \cdot d \cdot logP)\)这样的复杂度是正确的 代码 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e7 + 5;const int inf = 1e9 + 5;const int P = 1e9 + 7;const int zero = 0;int a[105], d, p, fac[maxn], s[105], pos[505][105], tmp[105], ans, sum, Q[505];int f[505];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int ksm(int x, int k)&#123; int cnt = 1; while(k)&#123; if(k &amp; 1)cnt = 1ll * cnt * x % P; x = 1ll * x * x % P; k &gt;&gt;= 1; &#125; return cnt % P;&#125;inline int calc(int *S, int *T)&#123; int ans = 1; for(register int i = 1; i &lt;= d; i++)&#123; tmp[i] = abs(T[i] - S[i]); if(S[i] &gt; T[i])return zero; &#125; for(register int i = d; i &gt;= 1; i--) s[i] = s[i + 1] + tmp[i]; for(register int i = 1; i &lt;= d; i++)&#123; int C = 1; C = 1ll * C * ksm(fac[s[i] - tmp[i]], P - 2) % P; C = 1ll * C * ksm(fac[tmp[i]], P - 2) % P * fac[s[i]] % P; ans = 1ll * ans * C % P; &#125; return ans % P;&#125;inline bool cmp(int x, int y)&#123; for(register int i = 1; i &lt;= d; i++) if(pos[x][i] != pos[y][i]) return pos[x][i] &lt; pos[y][i];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("cube.in", "r", stdin); freopen("cube.out", "w", stdout);#endif d = read(); p = read(); fac[1] = 1; fac[0] = 1; for(register int i = 1; i &lt;= d; i++) sum += (a[i] = read()); for(register int i = 2; i &lt;= sum; i++) fac[i] = 1ll * fac[i - 1] * i % P; for(register int i = 1; i &lt;= p; i++) for(register int j = 1; j &lt;= d; j++) pos[i][j] = read(); for(register int i = 1; i &lt;= p; i++)Q[i] = i; sort(Q + 1, Q + 1 + p, cmp); ans = calc(pos[0], a); //cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; endl; /*for(register int i = 1; i &lt;= p; i++)&#123; cout &lt;&lt; Q[i] &lt;&lt; " : "; for(register int j = 1; j &lt;= d; j++) cout &lt;&lt; pos[Q[i]][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125;*/ for(register int i = 1; i &lt;= p; i++)&#123; f[Q[i]] = calc(pos[0], pos[Q[i]]); for(register int j = 1; j &lt;= p; j++) if(Q[i] != Q[j]) f[Q[i]] = (f[Q[i]] - 1ll * f[Q[j]] * calc(pos[Q[j]], pos[Q[i]]) % P + P) % P; //cout &lt;&lt; "f[" &lt;&lt; Q[i] &lt;&lt; "] = " &lt;&lt; f[Q[i]] &lt;&lt; endl; &#125; for(register int i = 1; i &lt;= p; i++) ans = (ans - 1ll * f[i] * calc(pos[i], a) % P + P) % P; cout &lt;&lt; ans; return 0;&#125;/*2 12 11 02 12 12 0*/ Summary 推容斥式子时不要想当然, 想清楚再打 水水水 咕咕咕]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>DP</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈仙人掌和圆方树]]></title>
    <url>%2F2018%2F08%2F31%2FCactus%2F</url>
    <content type="text"><![CDATA[1.什么是仙人掌 给你一张无向图，一条边最多只在一个简单环当中的图被称之为仙人掌，例如： (图片出自BZOJ1023) 又或者这样 (图片源于网络) 2.什么是圆方树 仙人掌\(G = (V, E)\) 的圆方树 \(T = (V_T,E_T)\) 为满足以下条件的无向图： \(V_T = R_T \bigcup S_T, R_T = V , R_T \bigcap S_T \ne ∅\) , 我们称 \(R_T\) 集合为圆点, \(S_T\) 集合为方点 \(\large{\forall} {e} \large\in E\) , 若 \(e\) 不在任何简单环中, 则\(e \large\in E_T\) 对于每个仙人掌的简单环\(R\) ,存在方点\(P_R \large\in S_T\) , 并且 \(\large{\forall} {p} \large\in R\) 满足\((P_R, P) \large\in E_T\) , 即对每个环建立一个方点并连向这个环里的所有点 通俗一点的说 : 就是对于每个简单环都额外建一个方点 , 然后将每个圆点向方点连一条边 , 最后再将不连通的圆点连上原本有的边 , 就构成了圆方树 以下是对于圆方树正确性的证明： 感性证明 不在环上的点和边不会改变其树的性质, 而每个在环上的点都会连向方点, 形成一个菊花图, 所以这一定是一颗树 理论证明 原图中的环的个数为 \(|E| - |V| + 1\) , 则 \(|V_T| = |S_T| + |R_T| = |V| + |E| - |V| + 1 = |E| + 1, |E_T| = |E|\) (大小为\(\textbf{r}\)的环在仙人掌和圆方树中都是\(\textbf{r}\)条边) , 因此满足\(|V_T| = |E_T| + 1\) 3.如何构造圆方树 我们直接从任意一个点开始进行\(Tarjan\) 求点双联通分量 , 然后对于每一个点双联通分量建立一个方点 , 然后连边向这个点双联通分量里的每一个点连边, 最后处理没有连边的圆圆点对 \(PS\) : 个人建议通过并查集维护一下连通性在判断是否需要将原图中的边加入进来 , 而且这样可以避免重边带来的一些奇奇怪怪的\(bug\) 如图 : 虚边是原图上的边 , 实边是新建立的圆方树上的边 , 有一些虚边和实边重和的请况可以按照上述并查集的方法来维护 4.圆方树的性质 \(\large{\forall} {(x, y)} \large\in E_T, \{x, y\} \large\cap R_T \ne \varnothing\) , 通俗点说就是两个方点一定不会相连 在构造的过程中无论取什么点为根 , 构造出的圆方树都是一样的(在形态上) , 因此圆方树是无根树 定义 : 子仙人掌 &gt; 以\(\textbf{r}\)为根的仙人掌上的点\(\textbf{p}\)的子仙人掌是从仙人掌中去掉\(\textbf{p}\)到\(\textbf{r}\)的简单路径上的所有边之后 , \(\textbf{p}\)所在的联通块 以\(\textbf{r}\)为根的仙人掌中 , 点\(\textbf{p}\)的子仙人掌就是圆方树以\(\textbf{r}\)为根时点\(\textbf{p}\)的子树中的所有圆点所构成的图 5.利用圆方树和仙人掌解决问题 BZOJ4316小C的独立集 题面 : 求一颗仙人掌上的最大独立集 题解 : 我们先考虑如果在一棵树上应该怎么做 , 考虑状态\(f[i][0/1]\)表示这个点选或不选时以这个点为根的子树中的最大独立集是多少 , 那么转移就是 : \[ f[i][0] = \sum_{v \in son[i]}^{v} max(f[v][0], f[v][1]) \\ f[i][1] = \sum_{v \in son[i]}^{v} f[v][0] \] 我们再考虑环上如何转移 , 我们把这个环上深度最小的点称作这个环的根 , 我们还是考虑这个环的根选还是不选 , 然后我们把环展开 , 如果选择根节点的话 , 它两侧的点都是不能选的 , 否则就无所谓 , 然后剩下的就按树上的做法来搞就好了 , 所以转移就是 : \[ g[i][0] = max(g[i - 1][0], g[i - 1][1]) + f[id[i]][0] \\ g[i][1] = g[i - 1][0] + f[id[i]][1] \] 最后的答案就是\(max(f[root][0], f[root][1])\) , 这道题就这么愉悦的水过辣 BZOJ1023cactus仙人掌图 题目大意 : 给你一颗仙人掌 , 求仙人掌上的两点之间最短路的最大值 , 就是仙人掌的直径 题解 : 我们先考虑在树上怎么做 , 我们考虑状态\(f[i]\)表示在以这个点为根的子树当中, 经过\(i\)这个点的最长链的长度, 转移很显然, 就是: \[ f[i] = max \{ f[v] + w_{i,v}, v \in son[i] \} \] 然后我们就在转移的过程中更新一下答案就好了 然后还是一样的思路我们把环单独拎出来搞一下, 但是怎么弄呢, 发现不好在环上直接\(dp\), 因为环上的最短距离是不确定的, 我们考虑把环拆成链, 直接在链上\(dp\), 但是如果直接转移的话是\(n^2\)的, 式子是这样的: \[ ans = max(ans, max \{ f[r] + f[l] + r - l, r - l &lt; \frac{len}{2} \} ) \] 然后我们观察发现如果固定左端点, 新加入一个右端点我们可以将一些没有当前优的右端点给弹掉, 这个东西是可以用单调队列\(O(n)\)维护的, 具体的 : 如果当前队尾和队头的插值超过环的长度的二分之一, 弹掉队头, 直到符合条件为止 如果\(f[q[tail]] + q[tail] \leq f[i] + i\), 弹掉队尾, 直到符合条件为止 然后就可以开心的\(dp\)辣 BZOJ2125最短路 题目大意 : 给你一颗仙人掌, 有\(n\)次询问, 每次询问两点之间的最短路, \(n \leq 10^5\) 题解 : 对于上面的题, 我们可以不用建圆方树, 但是这道题我们考虑将圆方树建出来, 但是有一个问题, 我们怎么设定圆点到方点的边权, 这里有一个小技巧, 我们对于每一个环都建立一个根, 每个圆点到方点的边权就是这个圆点在其所在的环中到这个环的根的最短距离, 这样的话就可以保证从深度小的点向深度大的点遍历时, 是点与点之间的最短距离 建完图以后, 对其进行倍增预处理, 和剖分, 对于每次查询\((u, v)\), 我们我们求一下\(LCA(u, v)\) 如果\(LCA(u, v)\)是圆点那么就和普通的树上查询距离是一样的答案就是\(dis[u] + dis[v] - dis[LCA(u, v)]\), 如果是方点的话, 就说明\(u, v\)的祖先是在一个环上的, 这种情况不能直接搞, 我们用倍增向上跳到方点下的那个两个点\(fa_u, fa_v\), 让后求一下环上两点的最短距离\(L\),那么最后的答案就是\(dis[u] + dis[v] - dis[fa_u] - dis[fa_v] + L\) 6.广义仙人掌 填坑中..... 7.Summary 水水水 咕咕咕]]></content>
      <categories>
        <category>OI笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>仙人掌</tag>
        <tag>图论</tag>
        <tag>圆方树</tag>
        <tag>单调队列</tag>
        <tag>树链剖分</tag>
        <tag>倍增</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EducationalCodeForcesRound48]]></title>
    <url>%2F2018%2F08%2F23%2FEducationalCodeforcesRound48%20%2F</url>
    <content type="text"><![CDATA[Educational Codeforces Round 48 (Rated for Div. 2) A.Death Note 题目大意：告诉你你一天可以写\(a_i\)个字, 现在你有一本\(DeathNote\),这本书有\(n\)页,每页可以写\(m\)个字，问每天如果写\(a_i\)个字的话,一天要翻多少页 题解：你搞一个 \(sum\) 记录当前页你已经写了多少个字，然后每天要翻的页数就是$ $, \(sum = (sum + a_i)\%m\) 代码： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2e5 + 5;int a[maxn], n, m, ans;LL sum;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;int main()&#123; n = read(); m = read(); for(register int i = 1; i &lt;= n; i++)a[i] = read(); for(register int i = 1; i &lt;= n; i++)&#123; sum += a[i]; ans = sum / m; //while(sum &gt;= m)ans++, sum -= m; sum %= m; printf("%d ", ans); &#125; return 0;&#125; B.Segment Occurrences 题目大意：给你一个串\(s_0\) , 再给你一个匹配串\(s_1\) ,有\(m\)次询问每次问你\(s_0\)这个串在\([l, r]\)这个区间内，出现了多少次\(s_1\)串 题解：由于\(len(s_1) \leq 10^3\) , \(len(s_0) \leq 10^5\) ,所以我们直接对于\(s_0\)中的每一位的后\(len(s_1)\)位和\(s_1\)匹配一下，然后\(a_i = (s_1==s_{0l, r})\) ，用这个数组搞一下前缀和，每次之久\(O(1)\)查询就好了,但是注意如果查询\([l,r]\)区间最后的答案是\(sum[r - len(s_1) + 1] - sum[l - 1]\)而不是\(sum[r]-sum[l-1]\),然后匹配我用的是哈希，当然\(KMP\), 暴力匹配都是可以的 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 2e3 + 5;const int seed0 = 233;const int seed1 = 23331;int Q, sum[maxn], n, m;char s[maxn], s1[maxn];struct Hash&#123; ull base0, base1; Hash(ull X = 0, ull X0 = 0)&#123;base0 = X; base1 = X0;&#125; bool operator == (const Hash &amp;t) const &#123;return base0 == t.base0 &amp;&amp; base1 == t.base1;&#125;&#125;ex, op[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline Hash gethash(int pos, int len, char *s)&#123; ull base0 = 0, base1 = 0; for(register int i = pos; i &lt;= pos + len - 1; i++) base0 = base0 * seed0 + s[i]; for(register int i = pos; i &lt;= pos + len - 1; i++) base1 = base1 * seed1 + s[i]; return Hash(base0, base1);&#125;int main()&#123; n = read(); m = read(); Q = read(); scanf("%s%s", s + 1, s1 + 1); ex = gethash(1, m, s1); for(register int i = 1; i + m - 1 &lt;= n; i++)&#123; op[i] = gethash(i, m, s); sum[i] = sum[i - 1] + (op[i] == ex); &#125; for(register int i = 1; i &lt;= Q; i++)&#123; int l = read(), r = read(); if(r - l + 1 &lt; m)printf("0\n"); else printf("%d\n", sum[r - m + 1] - sum[l - 1]); &#125; return 0;&#125; C.Vasya And The Mushrooms 题目大意：有两排蘑菇，每行有\(n\)个，每个蘑菇都有一个生长速度\(a_i\), 一开始的初始时间是零，你在两个个子之间移动的速度是\(1m/s\) 每个相邻的格子之间的距离是一，最后你得到每个蘑菇的权值是\(a_i\cdot t_i\) ，\(t_i\)是你猜到这个蘑菇的时间，问你如何采摘才能让总权值最大 题解：这题然我们一次性拿完并且不能经过相同的蘑菇，那么很显然如果你在某一行上走的路径长度超过二的话那么你就必须得走到头然后从另一行绕回来，那么我们就可以枚举一下是从那一行的哪一列开始一直向前走的，此前我们必须得走蛇形的，例如： 所以我们枚举一下转折点就好了，关于统计答案我们处理一个蛇行走的第一行和第二行的前缀和(就是在蛇行走时的前缀和)分别为 \(s_0, s_1\)，和一个前缀和分别为\(ss_0, ss_1\)，和一个后缀和\(sss_0, sss_1\)，还有一个这样的东西 \[ ssa_{i} = \sum_{j=1}^{j\leq i}i\cdot a_j \] 和这样一个东西 \[ ssb_{1i}=\sum_{j=i}^{j \leq n}(n - j + 1) \cdot a_j \] 所以说对于一个转折点在第一行第\(i\)列的情况来说 \[ ans = s_{0i} + s_{1i} + (sum_{0n} - sum_{0i} + i \cdot (ss_{0n} - ss_{0i})) + (ssb_{1i} - ssb_{1n} + (n + i) \cdot (sss_{1i} - sss_{1n})) \] 还有一个是就是转折点在第二行第\(i\)列的情况，我就不打了，写着好麻烦，见代码，其实就是懒 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 3e5 + 5;const int seed0 = 233;const int seed1 = 23331;int n, a[maxn], b[maxn];LL ans, sum, sa[maxn], sb[maxn], ssa0[maxn], ssb0[maxn], ssa1[maxn], ssb1[maxn], s0[maxn], s1[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;int main()&#123; n = read(); for(register int i = 1; i &lt;= n; i++) s0[i] = s0[i - 1] + (a[i] = read()); for(register int i = 1; i &lt;= n; i++) s1[i] = s1[i - 1] + (b[i] = read()); for(register int i = 1; i &lt;= n; i++) ssb0[i] = ssb0[i - 1] + 1ll * i * b[i]; for(register int i = n; i &gt;= 1; i--) ssa1[i] = ssa1[i + 1] + 1ll * (n - i + 1) * a[i]; for(register int i = 1; i &lt;= n; i++) ssa0[i] = ssa0[i - 1] + 1ll * i * a[i]; for(register int i = n; i &gt;= 1; i--) ssb1[i] = ssb1[i + 1] + 1ll * (n - i + 1) * b[i]; ans = max(ans, sum); // -------------------------------------------------- // task 3 sum = 0; for(register int i = 1, tim = 1; i &lt;= n; i += 2, tim += 4)&#123; if(i &lt;= n)sb[i] = sb[i - 1] + 1ll * tim * b[i]; if(i &lt; n)sb[i + 1] = sb[i] + 1ll * (tim + 1) * b[i + 1]; &#125; for(register int i = 2, tim = 3; i &lt;= n; i += 2, tim += 4)&#123; if(i &lt;= n)sa[i] = sa[i - 1] + 1ll * tim * a[i]; if(i &lt; n)sa[i + 1] = sa[i] + 1ll * (tim + 1) * a[i + 1]; &#125; for(register int i = 1; i &lt;= n; i += 2)&#123; sum = 0; int tim = (i - 1) * 2; sum += sa[i - 1] + sb[i - 1]; sum += (ssa0[n] - ssa0[i - 1]) + 1ll * (tim - i) * (s0[n] - s0[i - 1]); sum += ssb1[i] + 1ll * (tim + n - i) * (s1[n] - s1[i - 1]); ans = max(ans, sum); &#125; for(register int i = 1; i &lt;= n; i += 2)&#123; sum = 0; int tim = i * 2; sum += sa[i] + sb[i]; sum += (ssb0[n] - ssb0[i]) + 1ll * (tim - i - 1) * (s1[n] - s1[i]); sum += ssa1[i + 1] + 1ll * (tim + n - i - 1) * (s0[n] - s0[i]); ans = max(ans, sum); &#125; cout &lt;&lt; ans; return 0;&#125; D.Vasya And The Matrix 题目大意：给你一个\(n \cdot m\)的矩阵，告诉你每一行和每一列的异或和，让你求出一种合法解 题解：我们考虑直接对前\(n-1\)行只填第一个数，这个数等于每一行的异或和，也就是说前\(n-1\) 的每一行的后\(m-1\)列都填零，最后一行的第一个数等于第一列的异或和异或上第一列的前\(n-1\)行的每一个数 然后对于最后一行的后\(m-1\)个数都填的是对应的每一列的异或和，如果最后一行的所有数异或起来不等于最后一行的异或和就是无解，否则就是就是合法解 代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 3e2 + 5;int n, m, c[maxn], r[maxn], mp[maxn][maxn];int cnow[maxn], rnow[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;int main()&#123; //cout &lt;&lt; (((1 &lt;&lt; 30) - 1) &lt;&lt; 1) + 1; 2147483647 n = read(); m = read(); for(register int i = 1; i &lt;= n; i++)c[i] = read(); for(register int i = 1; i &lt;= m; i++)r[i] = read(); for(register int i = 1; i &lt; n; i++) mp[i][1] = c[i], rnow[1] ^= c[i]; mp[n][1] = rnow[1] ^ r[1]; for(register int i = 2; i &lt;= m; i++) mp[n][i] = r[i], cnow[n] ^= r[i]; if((cnow[n] ^ mp[n][1]) != c[n])cout &lt;&lt; "NO"; else &#123; cout &lt;&lt; "YES" &lt;&lt; endl; for(register int i = 1; i &lt;= n; i++)&#123; for(register int j = 1; j &lt;= m; j++) cout &lt;&lt; mp[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; E.Rest In The Shades 题目大意：已知一个光源的纵坐标与横坐标的变化范围，现在\(x\)轴上有\(n\)条围栏(会挡住光线)，并且第一象限中有\(q\)个点，问你点在起点移动到终点的过程中\(q\)个点中每个点处于阴影的时间。\(PS\):光源的移动速度为\(1\)单位每秒， 并且保证线段不相交 题解：我们换一种方法理解一下这个题目，其实这个题目要求的东西可以转化为，\(q\)个点中每个点和每条线段的左右端点连线后在光源的纵坐标的位置会得到\(n\)个投影，然后问这\(n\)个投影和光源移动的那个线段的重合部分有多长，因为我们得到的是\(n\)个不相交的投影，所以我们直接离散一下值域，然后二分一下光源移动的线段的左端点与右端点，把处于这个范围中间的完整的投影加上，再算一下两端不完全重合的投影所覆盖的长度即可，如图： 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 2e5 + 5;const double eps = 1e-11;int n, Q;struct Node&#123;double l, r;&#125;t[maxn];double sum[maxn], y2, L, R;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int lower(int l, int r, double x)&#123; int mid = (l + r) / 2, ans = 0; while(l &lt;= r)&#123; mid = (l + r) / 2; if(t[mid].l &gt; x)r = mid - 1; else l = mid + 1, ans = mid; &#125; return ans;&#125;inline bool equ(double x, double y)&#123;return fabs(x - y) &lt;= eps;&#125;inline double getpos(double x2, double y2, double x3, double y3)&#123; double k = 0, b = 0; if(equ(x2, x3))return x2; k = (y2 - y3) / (x2 - x3); b = y2 - k * x2; return -b / k;&#125;int main()&#123; //cout &lt;&lt; (((1 &lt;&lt; 30) - 1) &lt;&lt; 1) + 1; 2147483647 y2 = read(); L = read(); R = read(); n = read(); for(register int i = 1; i &lt;= n; i++)&#123; t[i].l = read(); t[i].r = read(); sum[i] = sum[i - 1] + t[i].r - t[i].l; &#125; Q = read(); for(register int i = 1; i &lt;= Q; i++)&#123; double l = 0, r = 0, x = read(), y = read(), ans = 0; l = getpos(x, y, L, y2); r = getpos(x, y, R, y2); int posl = lower(0, n, l), posr = lower(0, n, r); if(posr == 0)ans = 0; else &#123; /*ans = min(r, max(l, t[posl].r)) - t[posl].l - fabs(l - t[posl].l); if(posr &gt; posl)&#123; ans += max(r, t[posr].r) - t[posr].l - fabs(r - t[posr].r); ans += sum[posr - 1] - sum[posl]; &#125;*/ ans = sum[posr - 1] - sum[posl - 1]; ans -= (min(l, t[posl].r) - t[posl].l); ans += max(r, t[posr].r) - t[posr].l - fabs(r - t[posr].r); &#125; printf("%.15lf\n", ans * (y - y2) / y); &#125; return 0;&#125; F.Road Projects 题目大意：给你一棵树，有\(m\)个询问，每个询问有一个\(x\),问你再这棵树上的任意两个没有直接的遍相连的节点中间加上一条边权为 \(v\) 的边，从\(1\)号结点到\(n\)号节点的路径上边权和的最小值最大可以为多少 原题题面写的真TM辣鸡，又扯又说不清 题解：考虑这样一个事实，无论加的边的权值是多少我们每次都贪心选取相同的两个节点来加边肯定是最优的。 那么怎么求这一对节点呢，我们可以设\(d_1[x]\)为\(1\)号结点到\(x\)号节点的权值，\(d_n[x]\)为\(n\)号节点到\(x\)号结点的权值，如果在\(x,y\)中间加了一条边 \[ ans = min(d_1[n], min(d_1[x]+v+d_n[y],d_1[y]+v+d_n[x])) \] 如果\(d_1[x]+v+d_n[y] \leq d_1[y]+v+d_n[x]\) 等价于 \(d_1[x] - d_n[x] \leq d_1[y]-d_n[y]\) ,所以我们直接按照这个为比较的依据把所有的点都丢进一个\(vector\)中，然后\(sort\)一下，再呗所有点都丢进一个\(set\)中，这回用 \(d_n[x]\) 做为排序依据，然后顺序枚举一下，每个节点求一个相对于这个节点最优另一个节点即\(set.end() - 1\)等价于\(set.rbegin()\)(反向迭代器), 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 3e5 + 5;const LL inf = (1ll &lt;&lt; 60);int n, m, cnt, head[maxn], pos[maxn];LL d1[maxn], dn[maxn], minv = inf, maxv;struct Graph&#123;int to, nt, w;&#125;e[maxn &lt;&lt; 1];vector&lt;pair&lt;LL, int&gt; &gt;o;set&lt;pair&lt;LL, int&gt; &gt;s0;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline void ini(int x, int y, int w)&#123;e[++cnt] = (Graph)&#123;y, head[x], w&#125;; head[x] = cnt;&#125;inline void dfs(int now, int fa, LL *d, LL dis)&#123; d[now] = dis; for(register int i = head[now]; i; i = e[i].nt)&#123; int v = e[i].to; if(v == fa)continue; dfs(v, now, d, dis + e[i].w); &#125;&#125;int main()&#123; n = read(); m = read(); for(register int i = 1; i &lt; n; i++)&#123; int x = read(), y = read(), w = read(); ini(x, y, w); ini(y, x, w); &#125; dfs(1, 1, d1, 0); dfs(n, n, dn, 0); for(register int i = 1; i &lt;= n; i++) o.push_back(make_pair(d1[i] - dn[i], i)); sort(o.begin(), o.end()); for(register int i = 0; i &lt; n; i++) pos[o[i].second] = i + 1; for(register int i = 1; i &lt;= n; i++) s0.insert(make_pair(dn[i], i)); for(register int i = 0; i &lt; o.size(); i++)&#123; int p = o[i].second; s0.erase(make_pair(dn[p], p)); for(register int u = head[p]; u; u = e[u].nt)&#123; int v = e[u].to; if(pos[v] &gt; pos[p]) s0.erase(make_pair(dn[v], v)); &#125; LL p0 = inf; if(!s0.empty()) maxv = max(maxv, s0.rbegin() -&gt; first + d1[p]); for(register int u = head[p]; u; u = e[u].nt)&#123; int v = e[u].to; if(pos[v] &gt; pos[p]) s0.insert(make_pair(dn[v], v)); &#125; &#125; for(register int i = 1; i &lt;= m; i++)&#123; int x = read(); printf("%lld\n", min(d1[n], maxv + x)); &#125; return 0;&#125; G.Appropriate Team 题目大意：给你一个值域为\(10^{18}\)的序列\(a\), 和一个\(X,Y\)，问你有多少对\(i,j\)满足存在一个\(V\), 使 \[ GCD(a_i,V) = X, LCM(a_j,V)=Y \] 特别的\(i,j\)可以相等 题解：由题意可知 $ V % X == 0, Y % V == 0 $ 所以如果\(Y \% X \neq 0\)则不存在\(V\)即\(ans=0\) 否则 \[ X = \prod P_{i}^{p_{xi}}, Y = \prod P_{i}^{p_{yi}}, a_j = \prod P_{i}^{p_{aji}} \] 对于 \(GCD(x,y)\) 是将每个\(x,y\) 的素因子的个数取个\(min\) 即 \[ GCD(x,y) = \prod P_i^{min(P_{xi}, P_{yi})} \] 而\(LCM(x,y)\) 则是取\(max\) \[ LCM(x,y) = \prod P_i^{max(P_{xi}, P_{yi})} \] 也就说如果对于\(GCD(a_i,V)\)的一个素因子\(P_i\)来说，如果\(P_{ai} &gt; P_{xi}\), 那么\(P_{Vi} = P_{xi}\), 否则就无所谓 反过来如果对于\(LCM(a_j,V)\)的一个素因子\(P_i\)来说，如果 \(P_{ai} &lt; P_{yi}\),那么\(P_{Vi}=P_{yi}\)。 至此我们可以这样看，对于每一个素因子\(P_i\),设\(l=P_{xi},r=P_{yi}\) 如果\(P_{ai}==l||P_{aj}==r\)则存在这样的一个素因子, 特别的如果\(l==r\)也一定会存在一个这样的素因子，当对于每一个素因子都成立时就存在一个\(V\), 因为一个值域为\(10^{18}\)的数，至多有\(15\)个不同的素因子, 所以我们可以直接搞一个二进制来表示一下对于每个素因子的状态，我们这样表示，如果对于一个素因子成立就把这一位设为\(1\)，所以对于每个\(a_i\)他都有两个二进制\(l_i\)和\(r_i\),最后要我们求的问题就可以转化为，从一个序列中取\(i,j\)使得\(l_i|r_j==(1&lt;&lt;15)-1\),但这样表示不太好看我们把不成立设为\(1\), 最后就是\(l_i \&amp; r_i==0\) , 最后就是怎么算，官方题解给的是\(n\cdot2^n\)，但是我并不会。我太菜辣 最后就是关于\(X,Y\)的素因数的分解，这里我用的是\(Pollard-rho\)算法，由于数据很毒瘤，这里一定要用龟速乘才能过，不然会爆 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ull;const int maxn = 2e5 + 5;const int inf = 1e9 + 7;LL minv[1 &lt;&lt; 16];LL numx[15], numy[15];LL n, a[maxn], x, y, A, B, facy[15000], ans;inline LL read()&#123; char ch = getchar(); LL u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline LL gcd(LL x, LL y)&#123;return y == 0 ? x : gcd(y, x % y);&#125;inline LL mul(LL x, LL y, LL p)&#123; LL cnt = 0; while(y)&#123; if(y &amp; 1)cnt = (cnt + x) % p; x = (x + x) % p; y &gt;&gt;= 1; &#125; return cnt;&#125;inline LL ksm(LL x, LL k, LL p)&#123; LL cnt = 1; while(k)&#123; if(k &amp; 1)cnt = mul(cnt, x, p); x = mul(x, x, p); k &gt;&gt;= 1; &#125; return cnt;&#125;inline bool judge(LL a, LL p)&#123; LL q = p - 1; int k = 0; while(q % 2 == 0) ++k, q &gt;&gt;= 1; LL v = ksm(a, q, p); if(v == 1 || v == p - 1)return false; while(k-- != 0)&#123; v = mul(v, v, p); if(v == p - 1)return false; &#125; return true;&#125;inline bool miller_rabbin(LL p)&#123; if(p == 2)return true; if(p % 2 == 0)return false; for(register int i = 1; i &lt;= 60; i++)&#123; LL a = rand() % (p - 1) + 1; if(judge(a, p))return false; &#125; return true;&#125;const int M = (1 &lt;&lt; 7) - 1;inline LL pollard_rho(LL n)&#123; if (n % 2 == 0) return 2; if (n % 3 == 0) return 3; LL x = 0, y = x, t = 1, q = 1, a = (rand() % (n - 1)) + 1; for (int k = 2;; k &lt;&lt;= 1, y = x, q = 1) &#123; for (int i = 1; i &lt;= k; ++i) &#123; x = (mul(x, x, n) + a) % n; q = mul(q, abs(x - y), n); if (!(i &amp; M)) &#123; t = gcd(q, n); if (t &gt; 1) break; &#125; &#125; if (t &gt; 1 || (t = gcd(q, n)) &gt; 1) break; &#125; if (t == n) &#123; t = 1; while (t == 1) t = gcd(abs((x = ((mul(x, x, n) + a) % n)) - y), n); &#125; return t;&#125;inline void findfac(LL x)&#123; if(x == 1)return; if(miller_rabbin(x))&#123;facy[++facy[0]] = x; return;&#125; LL p = x; while(p &gt;= x)p = pollard_rho(p); findfac(p); findfac(x / p);&#125;// 0 133056495 897612484786617600inline void dEBUG(LL *x, LL len)&#123; cerr &lt;&lt; "----------------------------------DEBUG----------------------------------" &lt;&lt; endl; for(register int i = 0; i &lt;= len; i++) cerr &lt;&lt; x[i] &lt;&lt; " "; cerr &lt;&lt; endl; cerr &lt;&lt; "----------------------------------DEBUG----------------------------------" &lt;&lt; endl;&#125;int main()&#123; srand(19260817); n = read(); A = x = read(); B = y = read(); if(y % x != 0)&#123;cout &lt;&lt; 0; return 0;&#125; for(register int i = 1; i &lt;= n; i++)a[i] = read(); findfac(B); sort(facy + 1, facy + 1 + facy[0]); facy[0] = unique(facy + 1, facy + 1 + facy[0]) - facy - 1; for(register int i = 1; i &lt;= facy[0]; i++) while(B % facy[i] == 0)B /= facy[i], numy[i]++; for(register int i = 1; i &lt;= facy[0]; i++) while(A % facy[i] == 0)A /= facy[i], numx[i]++; //dEBUG(facy, facy[0]); //dEBUG(numx, facy[0]); //dEBUG(numy, facy[0]); for(register int i = 1; i &lt;= n; i++)&#123; if(a[i] % x != 0)continue; int maskx = 0; LL T = a[i]; for(register int k = 1; k &lt;= facy[0]; k++)&#123; int p = 0; if(numx[k] == numy[k])continue; while(T % facy[k] == 0)T /= facy[k], p++; maskx |= ((p &gt; numx[k]) &lt;&lt; (k - 1)); &#125; minv[maskx]++; &#125; for(register int i = 0; i &lt; facy[0]; i++) for(register int G = 0; G &lt; (1 &lt;&lt; facy[0]); G++) if(G &amp; (1 &lt;&lt; i))minv[G] += minv[G ^ (1 &lt;&lt; i)]; int MK = (1 &lt;&lt; facy[0]) - 1; for(register int i = 1; i &lt;= n; i++)&#123; if(y % a[i] != 0)continue; int masky = 0; LL T = a[i]; for(register int k = 1; k &lt;= facy[0]; k++)&#123; int p = 0; while(T % facy[k] == 0)T /= facy[k], p++; masky |= ((p &lt; numy[k]) &lt;&lt; (k - 1)); &#125; ans += minv[masky ^ MK]; &#125; //dEBUG(minv, n); dEBUG(maxv, n); cout &lt;&lt; ans; return 0;&#125; Summary:读懂题目很重要，打代码之前想清楚为什么，不要不懂装懂，打完就完事了 Thinck Twice, Code once.]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Hash</tag>
        <tag>KMP</tag>
        <tag>Greedy</tag>
        <tag>计算几何</tag>
        <tag>Pollard-rho</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForcesRound499(Div.2)]]></title>
    <url>%2F2018%2F07%2F31%2FCodeforcesRound499(Div.2)%2F</url>
    <content type="text"><![CDATA[Codeforces Round #499 (Div.2) A. Stages 题目大意：给你一个长度为\(n\)的字符串， 让你从其中拿出\(k\)个字符， 要求权值最小， 并且拿出的\(k\)个字符中，至少要有一个间隔 题解： 直接将字符串\(sort\)一下就好了，每次间隔一个取， 如果能取足\(k\)个那么就是满足条件的，否则就输出\(-1\) PS : 这里的间隔取不是指的字母在序列中的位置，而是在\(26\)个字母中的位置 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e2 + 5;int n, k, ans;char s[maxn];int main()&#123; scanf("%d%d%s", &amp;n, &amp;k, s + 1); sort(s + 1, s + 1 + n); int p = 1, l = 0; while(k &amp;&amp; p &lt;= n)&#123; if(s[p] - s[l] &gt;= 2)&#123; ans += s[p] - 'a' + 1; k--; l = p; &#125; p++; &#125; if(k)cout &lt;&lt; "-1"; else cout &lt;&lt; ans; return 0;&#125; B. Planning The Expedition 题目大意： 你有一些物品，每个物品都只有若干个，有\(n\)个人， 每个人只能吃同种物品，并且每天只吃一个，问你\(n\)个人最多能吃几天 题解： 我们考虑直接二分一个天数\(mid\)，线性扫描所有物品，每种物品的数量\(k_i\), 有\(m\)种物品，则\(cnt = \sum_{i=1}^m\lfloor \frac{k_i}{mid} \rfloor\), 如果最后\(n\) \(\leq\) \(cnt\)，就成立，否则不成立 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;int n, m, a[maxn], bac[maxn], tmp[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline bool check(int mid)&#123; int x = n; for(register int i = 1; i &lt;= 100; i++) x -= bac[i] / mid; return x &lt;= 0;&#125;inline int binary(int l, int r)&#123; int mid = (l + r) / 2, ans = 0; while(l &lt;= r)&#123; mid = (l + r) / 2; if(check(mid))l = mid + 1, ans = mid; else r = mid - 1; &#125; return ans;&#125;int main()&#123; n = read(); m = read(); if(n &gt; m)&#123; cout &lt;&lt; "0"; return 0; &#125; for(register int i = 1; i &lt;= m; i++)bac[a[i] = read()]++; cout &lt;&lt; binary(1, 1000); return 0;&#125; C. Fly 题目大意： 你有一架飞机，质量为\(m\), 要求从\(1\)好星球飞到\(n\)星球, 在每个星球起飞或者降落都有一个系数\(k_i\), 起飞的耗油量为起飞前飞机质量和油的质量的和除以\(k_i\), 问你最少需要带多少油 题解： 再次考虑二分答案， 直接按照题目的意思模拟一下，判断最后的剩余的质量是否大于飞机的质量\(m\) PS: 注意精度问题, \(eps = 1e-8\)即可， 否则会可能会\(T\) 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;const int inf = 1e9 + 7;const double eps = 1e-8;int n;double m, a[maxn], b[maxn];inline bool check(double mid)&#123; double now = m + mid; for(register int i = 1; i &lt; n; i++)&#123; now -= now / a[i]; now -= now / b[i + 1]; &#125; now -= now / a[n]; now -= now / b[1]; return now + eps &gt;= m;&#125;double binary(double l, double r)&#123; double mid = (l + r) / 2, ans = 0; while(l &lt;= r + eps)&#123; mid = (l + r) / 2; if(check(mid))r = mid - eps, ans = mid; else l = mid + eps; &#125; return ans;&#125;int main()&#123; scanf("%d%lf", &amp;n, &amp;m); for(register int i = 1; i &lt;= n; i++)&#123; scanf("%lf", &amp;a[i]); if(a[i] &lt;= 1)&#123; cout &lt;&lt; "-1"; return 0; &#125; &#125; for(register int i = 1; i &lt;= n; i++)&#123; scanf("%lf", &amp;b[i]); if(b[i] &lt;= 1)&#123; cout &lt;&lt; "-1"; return 0; &#125; &#125; printf("%.9lf", binary(0, double(inf))); return 0;&#125; D. Rocket 题目大意：一道交互题， 要你猜一个数字\(x\)\((x \leq m)\)， \(m\)给出，并且回答机制是一种循环， 我们知道这个循环的长度为\(n\)\((n \leq 30)\), 这个序列是一个\(01\)序列， 如果是\(0\)那么回答的就是假话，是\(1\)回答的就是真话，要求最多询问六十次，求出这个数字 题解： 首先我们可以用\(n\)次询问确定这个\(01\)序列，然后再用剩余询问次数确定这个数字，我们的前\(n\)次询问每次都问\(m\), 如果问答大于就是说谎， 否则就是真话， 那么通过\(n\)次询问，\(01\)序列就确定下来了，然后就是普通的二分了 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int maxn = 1e5 + 5;int n, m, a[maxn];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int check(int mid, int tot)&#123; cout &lt;&lt; mid &lt;&lt; endl; fflush(stdout); int t; cin &gt;&gt; t; if(t == 0)exit(0); if (a[(tot % n == 0) ? n : tot % n] == 0) t = -t; return t;&#125;int main()&#123; cin &gt;&gt; m &gt;&gt; n; for(register int i = 1; i &lt;= n; i++)&#123; int t; cout &lt;&lt; m &lt;&lt; endl; fflush(stdout); cin &gt;&gt; t; if(t == 0)return 0; else if(t == -1)a[i] = 1; else a[i] = 0; &#125; int l = 1, r = m, mid = (l + r) / 2, tot = n; while(l &lt;= r)&#123; mid = (l + r) / 2; int t = check(mid, ++tot); if(t == -1) r = mid - 1; else l = mid + 1; &#125; return 0;&#125; E. Border 题目大意：我们有\(n\)种物品，每种物品都有一个价值\(val_i\), 并且都可以无限选择，问你在模\(k\)的意义下能够组成多少种不同的价值, 输出种类数， 并且输出方案 题解：由\(n\)个数的斐蜀定理可知，\(\sum_{i=1}^n a_ix_i = p \cdot gcd \{ x_i\}\) , 假如我们有三个物品 \(a_1x_1 + a_2x_2 +a_3x_3 = p\cdot gcd\{x_1, x_2, x_3\}\) , 这里的\(a_i\)可以为负数，但是题目中必须得选非负数个那我们转换一下 \(a_1x_1 +a_2x_2 +a_3x_3\) 和 \(a_1x_1 + a_2x_2 + a_3x_3 + a_1&#39; \cdot kx_1 + a_2&#39; \cdot kx_2 + a_3&#39; \cdot kx_3\) 在模\(k\) 的意义下是一样的所以这个定理在模意义下是可以用的， 所以本题就很简单了，答案就是\(t \cdot gcd\{x_i\}, t \in [0,n]\) 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int n, t, k;inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int gcd(int x, int y)&#123;return y == 0 ? x : gcd(y, x % y);&#125;set&lt;int&gt;st;int main()&#123; n = read(); k = read(); t = read(); for(register int i = 2; i &lt;= n; i++) t = gcd(t, read()); for(register int i = 0; i &lt;= n; i++) st.insert((i * t) % k); cout &lt;&lt; st.size() &lt;&lt; endl; for(set&lt;int&gt; :: iterator iter = st.begin(); iter != st.end(); iter++) cout &lt;&lt; (*iter) &lt;&lt; " "; return 0;&#125; F. Mars rover 题目大意：我们有一棵二叉树，在所有的非叶子节点上有一个二进制运算符，由每个叶子节点向上合并到根节点可以得到一个值，问你修改每一个叶子节点的值时最后的答案是多少(每个叶子节点的权值都是\(0\)或\(1\))， 题解：一遍\(dfs\)求出一开始的答案，再用一次\(dfs\)求出每次修改一个节点的权值会不会影响答案，关键是第二次\(dfs\)怎么写，我们考虑除了&quot;与&quot;和&quot;或&quot;其他的二进制运算符只要改变其儿子节点的权值就会改变自己的权值，既然知道了这一点我们特判一下就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6 + 5;const int inf = 1e9 + 7;int n, ch[maxn][2], ok[maxn], w[maxn];char s[maxn][5];inline int read()&#123; char ch = getchar(); int u = 0, f = 1; while(!isdigit(ch))&#123;if(ch == '-')f = -1; ch = getchar();&#125; while(isdigit(ch))&#123;u = u * 10 + ch - 48; ch = getchar();&#125; return u * f;&#125;inline int check(int now, int x0, int x1)&#123; switch(s[now][1])&#123; case 'A': return x0 &amp; x1; case 'O': return x0 | x1; case 'X': return x0 ^ x1; &#125;&#125;inline int dfs(int now)&#123; if(~w[now])return w[now]; if(s[now][1] == 'N')return w[now] = dfs(ch[now][0]) ^ 1; else return w[now] = check(now, dfs(ch[now][0]), dfs(ch[now][1]));&#125;inline void dfs(int now, int de)&#123; if(s[now][1] == 'N')&#123; ok[now] = de &amp; 1; if(s[ch[now][0]][1] != 'I')dfs(ch[now][0], ok[now]); else ok[ch[now][0]] = ok[now]; &#125; else if(s[now][1] == 'X')&#123; ok[now] = de &amp; 1; if(s[ch[now][0]][1] != 'I')dfs(ch[now][0], ok[now]); else ok[ch[now][0]] = ok[now]; if(s[ch[now][1]][1] != 'I')dfs(ch[now][1], ok[now]); else ok[ch[now][1]] = ok[now]; &#125; else if(s[now][1] == 'O')&#123; ok[now] = de &amp; 1; if(s[ch[now][0]][1] != 'I')dfs(ch[now][0], ok[now] &amp; (w[ch[now][1]] != 1)); else ok[ch[now][0]] = ok[now] &amp; (w[ch[now][1]] != 1); if(s[ch[now][1]][1] != 'I')dfs(ch[now][1], ok[now] &amp; (w[ch[now][0]] != 1)); else ok[ch[now][1]] = ok[now] &amp; (w[ch[now][0]] != 1); &#125; else if(s[now][1] == 'A')&#123; ok[now] = de &amp; 1; if(s[ch[now][0]][1] != 'I')dfs(ch[now][0], ok[now] &amp; (w[ch[now][1]] == 1)); else ok[ch[now][0]] = ok[now] &amp; (w[ch[now][1]] == 1); if(s[ch[now][1]][1] != 'I')dfs(ch[now][1], ok[now] &amp; (w[ch[now][0]] == 1)); else ok[ch[now][1]] = ok[now] &amp; (w[ch[now][0]] == 1); &#125;&#125;int main()&#123; n = read(); memset(w, -1, sizeof(w)); for(register int i = 1; i &lt;= n; i++)&#123; scanf("%s", s[i] + 1); if(s[i][1] == 'I')w[i] = read(); else if(s[i][1] == 'A' || s[i][1] == 'X' || s[i][1] == 'O') ch[i][0] = read(), ch[i][1] = read(); else ch[i][0] = read(); &#125; w[1] = dfs(1); dfs(1, 1); for(register int i = 1; i &lt;= n; i++) if(s[i][1] == 'I')printf("%d", w[1] ^ ok[i]); return 0;&#125; Summary : 水题集合]]></content>
      <categories>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>模拟</tag>
        <tag>斐蜀定理</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2017TG Solution]]></title>
    <url>%2F2017%2F11%2F12%2FNOIP2017%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[\(Naive\)选手爆零记 NOIP2017 D1T1小凯的疑惑 luogu P2737麦香牛块Beef McNuggets 原题弱化版。 数论题，个人感觉并没有什么意义（在NOIP上考）既不考查代码能力，也只会增加其他人的翻车几率（逃 代码如下： 12345678#include &lt;iostream&gt;using namespace std;long long n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;(n-1)*(m-1)-1; return 0;&#125; 这边给出证明。 定理: 对于正整数\(p,q\)满足\(gcd(p,q)=1\),我们有\(px+qy=n\)无非负整数解的最大正整数\(n\)为\(pq−p−q\). 证明如下: 我们首先利用反证法, 证明\(px + qy \ne pq - p - q\): 我们假设存在正整数\(x\)和\(y\)使得\(px + qy = pq - p - q\), 则有 \[px + qy = pq - p - q\] \[p(x + 1) + q(y + 1) = p\] \[\because gcd(p, q) = 1,p | q(y + 1)\] \[\therefore p | y + 1 \] 同理, \[q | x + 1\] 接着我们令\(y + 1 = pj\),$ x + 1 = qk$. 则有 \[pqk + qpj = pq \] \[pq(j + k) = pq\] 注意到\(x, y \ge 0\), 我们有\(y + 1 \ge 1\)且\(x + 1 \ge 1\), 因而\(j \ge 1\)且\(k \ge 1\). 因而\(j + k \ge 2\), 因而假设不成立. 得证. 证明转自 NOIP2017 D1T2时间复杂度 看到这道题就心疼，NOIP的时候并没有写出来，可能是因为并没有学栈的原因，所以当时没有写出来，今天学长们讲了栈，我就来把这道题A了 学长们还说递归可以A来着，好像还很简单 思路： 好像并没有什么思路，就是遇到\(F\)就就压栈，遇到\(E\)就把最上层的栈弹出，大概像循环嵌套，括号匹配，表达式求值都可以用栈实现吧！ 传送门：NOIP2013普及组 表达式求值,NOIP2005提高组T4 等价表达式(毒瘤题，数据很鬼畜) 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;char ans[11][20],e[11][110][110];int T,judge[1&lt;&lt;9],deepth,is[1&lt;&lt;9],top,maxdeepth,fff,ff;//ff是一个标记，来记录是否有重读的变量//fff也是一个标记，用于记录一个循环的初始值大于结束值的请况//top表示当前栈指向哪一层//maxdeepth用来记录此程序的循环嵌套的最大层数//deepth用于更新long long num[11][110][5],x;int L,a,b,len,lennum,realdeepth;//realdeepth就是输入所给的复杂度struct node&#123;int is,isdi,deep;&#125;st[11][110];//一个手写结构体的栈，用来记录状态int main()&#123; //freopen("complexity.in","r",stdin); //freopen("complexity.out","w",stdout); scanf("%d",&amp;T); for(int i=1;i&lt;=T;i++)&#123; scanf("%d",&amp;L);getchar();len=0;realdeepth=0; while(true)&#123; char s=getchar(); if(s=='\n')break; if(s&gt;='0'&amp;&amp;s&lt;='9')realdeepth=realdeepth*10+s-'0';//算realdeepth ans[i][++len]=s; &#125; //memset(st,0,sizeof(st)); memset(judge,0,sizeof(judge)); memset(is,0,sizeof(is)); ff=0;top=0;maxdeepth=0;deepth=0;fff=1;a=0;b=0; //每一组数据都要初始化所有的标记，不要忘 for(int j=1;j&lt;=L;j++)&#123; len=0;x=0;lennum=0; while(true)&#123; char s=getchar(); if(s!='\n')&#123; if(s&gt;='0'&amp;&amp;s&lt;='9')e[i][j][++len]=s,x=x*10+s-'0'; else if((s&gt;='a'&amp;&amp;s&lt;='z'&amp;&amp;s!='n')||(s&lt;='Z'&amp;&amp;s&gt;='A'))e[i][j][++len]=s; else if(s=='n')e[i][j][++len]=s,x=1&lt;&lt;30;//n就标记为（1&lt;&lt;30） else if(s==' ')&#123; e[i][j][++len]=s; if(x)num[i][j][++lennum]=x,x=0; //我是直接把循环中的两个值提取出来了，用整形来存比较好用 &#125; &#125; else if(s=='\n')&#123; if(x)num[i][j][++lennum]=x,x=0; break; &#125; &#125; if(e[i][j][1]=='E')a++;//预判ERR else if(e[i][j][1]=='F')b++; &#125; if(a!=b)&#123;printf("ERR\n");continue;&#125; for(int j=1;j&lt;=L;j++)&#123; if(e[i][j][1]=='F')&#123; st[i][++top].isdi=e[i][j][3]; st[i][top].deep=deepth;//记录入栈时的deepth if(judge[e[i][j][3]])ff=1;//重复就记录 else judge[e[i][j][3]]=1;//标记变量 if(ff)break;//退出循环 if(num[i][j][1]!=(1&lt;&lt;30))&#123;//判断两个变量的初始值和末状态值 if(num[i][j][2]&gt;=num[i][j][1]&amp;&amp;num[i][j][2]!=(1&lt;&lt;30))st[i][top].is=1; else if(num[i][j][2]&lt;num[i][j][1]&amp;&amp;num[i][j][2]!=(1&lt;&lt;30))st[i][top].is=-1; //记录一个循环的初始值大于结束值的请况，且is=-1 else if(num[i][j][2]==(1&lt;&lt;30))st[i][top].is=2;//不是常数的话is为2 &#125; else if(num[i][j][1]==(1&lt;&lt;30))&#123; if(num[i][j][2]!=(1&lt;&lt;30))st[i][top].is=-1;//同理 else if(num[i][j][2]==(1&lt;&lt;30))st[i][top].is=1; &#125; if(st[i][top].is==-1)fff--; //把标记--，应为有可能多层都是不合法的循环（我一开始就是被这个坑了，结果debug了好长时间） if(st[i][top].is==2&amp;&amp;fff==1)deepth++;//合法就更新deepth maxdeepth=max(maxdeepth,deepth);//看是否可以更新maxdeepth &#125; else if(e[i][j][1]=='E')&#123; if(st[i][top].is==-1)fff++; judge[st[i][top].isdi]=0; deepth=st[i][top].deep; top--; //还原所有的标记，有点像递归回溯 &#125; &#125; if(ff)&#123;printf("ERR\n");continue;&#125; if(ans[i][3]=='n')&#123; if(realdeepth==maxdeepth)printf("Yes\n"); else printf("No\n"); &#125; else if(ans[i][3]&gt;='0'&amp;&amp;ans[i][3]&lt;='9')&#123; if(maxdeepth==0)printf("Yes\n"); else printf("No\n"); &#125; //最后判断输出就没有什么好说的了 &#125; return 0;&#125; NOIP2017 D2T1奶酪 这题嘛其实跟luogu上的一道题很像，因为被那道题卡了很久所以NOIp一下就想到了，但那道题是一个二维的，这个题改成了三维，这个几乎上是没有什么影响的，就是距离公式变了而已，还有就是那道题是要构造最小生成树，而NOIp的这道只用判断两个边界是否联通就好了，其实NOIp的比luogu上的这道还好写一些传送门 P1783 海滩防御 主要思路 将所有点都存入一个数组，然后把两个边界都存进去，然后跑一个\(N^2\) 就行了，这里就不多赘述，具体的细节处理见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;int T,n,h,r,fa[1100];struct node&#123;int x,y,z;&#125;t[21][1100];int findx(int x)&#123; if(fa[x]==x)return fa[x]; return fa[x]=findx(fa[x]);//并查集压缩路径（mmp考试的时候太紧张了把压缩路径敲掉了，直接return findx(fa[x])掉了50分还是60分，心疼啊！！所以压缩路径一定不能掉）&#125;void mergex(int x,int y)&#123;fa[findx(x)]=findx(y);&#125;//合并函数double dis(int x,int y,int z,int x2,int y2,int z2)&#123; ll disx,disy,disz; disx=(ll)(x-x2)*(x-x2);disy=(ll)(y-y2)*(y-y2);disz=(ll)(z-z2)*(z-z2); return sqrt(disx+disz+disy);&#125;//这个是求两点之间距离的函数，值得一提的是这个函数要用到开方，但是开方的运算量是很大的，也就是常数很大，要是出题人搞几组毒瘤数据估计又要死一片（比如说我），所以你可以改成return 一个乘积，代码我也会贴到下面（不过是我高二学长的）int main()&#123; //freopen(&quot;cheese.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;cheese.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=T;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;h,&amp;r); for(int j=0;j&lt;=n+1;j++)fa[j]=j; for(int j=1;j&lt;=n;j++)&#123; int x,y,z;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); t[i][j].x=x;t[i][j].y=y;t[i][j].z=z; &#125;t[i][n+1].z=h; for(int j=0;j&lt;=n+1;j++) for(int k=0;k&lt;=n+1;k++)&#123; int x,y,z,x2,y2,z2,disr=r*2; x=t[i][j].x;y=t[i][j].y;z=t[i][j].z; x2=t[i][k].x;y2=t[i][k].y;z2=t[i][k].z; if(j==0||j==n+1)&#123;x=x2,y=y2;disr=r;&#125;//边界特判 if(k==0||k==n+1)&#123;x2=x,y2=y;disr=r;&#125;//边界特判 double dist=dis(x,y,z,x2,y2,z2); if(dist&lt;=disr)mergex(j,k);//如果可以就合并然后 &#125; if(findx(0)==findx(n+1))printf(&quot;Yes\n&quot;);//如果联通就输出 else printf(&quot;No\n&quot;); &#125; return 0;&#125; PS：我这个代码一看就很low，也很慢跑了800多ms，下面再来看看我学长的代码，这个只跑了150ms 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 1e4;typedef long long ll;struct Point &#123; int x, y, z; void read() &#123; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z); &#125;&#125;p[maxn];struct MFS &#123; int fa[maxn]; void clear(int x) &#123; for (int i = 1; i &lt;= x; i++) fa[i] = i; &#125; int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125; void merge(int x, int y) &#123; if (find(x) == find(y)) return; fa[find(x)] = find(y); &#125;&#125;s;ll dis(Point a, Point b) &#123; ll x = (ll)a.x - b.x; ll y = (ll)a.y - b.y; ll z = (ll)a.z - b.z; return x * x + y * y + z * z;&#125;int main() &#123; //freopen(&quot;cheese.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;cheese.out&quot;, &quot;w&quot;, stdout); int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; int n, h, r; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;h, &amp;r); int S = n + 1, T = n + 2; ll R = ((ll)r * 2) * ((ll)r * 2); s.clear(n + 2); for (int i = 1; i &lt;= n; i++) &#123; p[i].read(); if ((ll)p[i].z - r &lt;= 0) s.merge(i, S); if ((ll)p[i].z + r &gt;= h) s.merge(i, T); &#125; bool suc = false; for (int i = 1; i &lt;= n &amp;&amp; !suc; i++) for (int j = i + 1; j &lt;= n &amp;&amp; !suc; j++) if (dis(p[i], p[j]) &lt;= R) &#123; s.merge(i, j); if (s.find(S) == s.find(T)) suc = true; &#125; if (s.find(S) == s.find(T)) suc = true; if (suc) printf(&quot;Yes\n&quot;); else printf(&quot;No\n&quot;); &#125; return 0; &#125;/*51 6 42933 3 -21 9 866-4 4 31 9 31712 0 -31 10 19401 0 -51 8 41501 0 -4*/ 一看就很高端，还把最小生成树（MFS）封装了，我也不是很懂，dalao就看看把！！！ ## D2T2 宝藏 这道题一看就应该是状压DP,这道题的题目就不多赘述了 用dp[i]来表示状态i下的最优方案,dis[j]表示j到根节点的距离（题目中所描述的K）用dfs来更新答案，下面直接上代码，代码附注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define inf 2147483647using namespace std;int dp[1&lt;&lt;13],dis[15],G[15][15],isG[15][15],n,m,ans=inf;//isG表示x,y之间是否有边//点只有十二个直接上邻接矩阵即可void insert(int x,int y,int w)&#123;G[x][y]=w;G[y][x]=w;isG[x][y]=1;isG[y][x]=1;&#125;//插边函数void dfs(int x)&#123; for(int i=1;i&lt;=n;i++)&#123; //枚举你所选点集中的每个点 if((1&lt;&lt;(i-1))&amp;x)&#123; for(int j=1;j&lt;=n;j++)&#123; if(!(1&lt;&lt;(j-1)&amp;x)&amp;&amp;isG[i][j]) //判断能否选 if(dp[1&lt;&lt;(j-1)|x]&gt;dp[x]+dis[i]*G[i][j])&#123; //有没有更新的必要 int temp=dis[j]; dis[j]=dis[i]+1; dp[1&lt;&lt;(j-1)|x]=dp[x]+dis[i]*G[i][j]; dfs(1&lt;&lt;(j-1)|x); dis[j]=temp; &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); memset(G,63,sizeof(G));//赋较大初值 for(int i=1;i&lt;=m;i++)&#123; int x,y,w;scanf("%d%d%d",&amp;x,&amp;y,&amp;w); if(w&lt;G[x][y])insert(x,y,w); &#125; for(int i=1;i&lt;=12;i++)&#123; memset(dis,63,sizeof(dis)); for(int j=1;j&lt;=(1&lt;&lt;n)-1;j++)dp[j]=inf; //每枚举一遍根节点就重置一遍 dis[i]=1;dp[1&lt;&lt;(i-1)]=0; dfs(1&lt;&lt;(i-1)); ans=min(ans,dp[(1&lt;&lt;n)-1]);//看答案是否能更新 &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>模拟</tag>
        <tag>dfs</tag>
        <tag>状态压缩</tag>
        <tag>并查集</tag>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
