<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Streaming#5模拟赛</title>
      <link href="/2018/09/02/20180902/"/>
      <url>/2018/09/02/20180902/</url>
      <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12wIROa0MTsCi/L4co5ovnhyPCGXuu9oqIMj3qHnqHD3cfmBs4X9z8fDc!/r/dPMAAAAAAAAA"> <a id="more"></a></p><h1 id="streaming5-题解报告"><a href="http://www.vixbob-lwc.pw/pdf/2018.9.2.pdf" target="_blank" rel="noopener">Streaming#5 题解报告</a></h1><h2 id="t1.珠">T1.珠</h2><p>题目大意 : 给你一个长度为<span class="math inline">\(n\)</span>的数字环, 你可顺时针或者逆时针选择一个子序列, 满足子序列的以<span class="math inline">\(2\)</span>开头, 后面的数字都是<span class="math inline">\(3\)</span>, 求最长子序列</p><p>题解 : 我们考虑对于每一个数字为<span class="math inline">\(2\)</span>的位置向左边和右边二分一个位置, 使得这个位置到数字<span class="math inline">\(2\)</span>中间全是<span class="math inline">\(3\)</span>, 所以我们必须得先处理处两个数组<span class="math inline">\(preL, preR\)</span>, 表示从一个为<span class="math inline">\(3\)</span>的位置向左向右全部都是<span class="math inline">\(3\)</span>的结束位置, 这样就可以二分了, 特别的如果你向右边二分出的位置为这个序列的末尾, 那你必须从这个序列的开头再次二分一个位置, 因为这个是一个环, 头尾可以相接</p><p>复杂度为<span class="math inline">\(O(nlogn)\)</span></p><p>代码 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> posR[maxn], posL[maxn], ans, L, R, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binaryR</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, ans = l - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(posR[mid] == i)l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binaryL</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, ans = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(posL[mid] == i)r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"beads.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"beads.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'3'</span>)posR[i] = (s[i - <span class="number">1</span>] == s[i]) ? posR[i - <span class="number">1</span>] : i;</span><br><span class="line"><span class="keyword">else</span> posR[i] = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">if</span>(s[i] == <span class="string">'3'</span>)posL[i] = (s[i + <span class="number">1</span>] == s[i]) ? posL[i + <span class="number">1</span>] : i;</span><br><span class="line"><span class="keyword">else</span> posL[i] = -inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i] != <span class="string">'2'</span>)<span class="keyword">continue</span>;</span><br><span class="line">R = binaryR(i + <span class="number">1</span>, n, i + <span class="number">1</span>), L = binaryR(<span class="number">1</span>, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">ans = max(ans, R - i + <span class="number">1</span> + L * (R == n));</span><br><span class="line">R = binaryL(i + <span class="number">1</span>, n, n), L = binaryL(<span class="number">1</span>, i - <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">ans = max(ans, i - L + <span class="number">1</span> + (n - R + <span class="number">1</span>) * (L == <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">"TvT"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'2'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans; i++)<span class="built_in">putchar</span>(<span class="string">'3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">323</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">333</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2332323333</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">33332233233</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="t2.免农">T2.免农</h2><p>题目大意 : 一开始你有两个免子, 下一个时刻, 你的免子会变成当前时刻的两倍, 然后我们会将这些免子分为若干组, <span class="math inline">\(k\)</span>个为一组, 特别的如果存在一组, 这一组里只有一个免子, 那么这个免子就会死去, 求<span class="math inline">\(n\)</span>时刻时免子的个数对<span class="math inline">\(p\)</span>取余的结果</p><p>题解 :</p><ul><li>考虑如果<span class="math inline">\(k\)</span>为偶数的话, 是不会存在单个免子为一组的, 所以最后的答案就是<span class="math inline">\(2^{n + 1} \% p\)</span></li><li>如果<span class="math inline">\(k\)</span>为奇数的话, 当<span class="math inline">\(2^{q} \% k == 1\)</span>的话那么在<span class="math inline">\(q\)</span>时刻之后, 就不会有免子再会落单了, 并且可以证明在<span class="math inline">\(k\)</span>个时刻以内, 一定存在一个时刻<span class="math inline">\(t\)</span>, 使得<span class="math inline">\(2^t \% k == 1\)</span>, 所以直接模拟就好了</li></ul><p>复杂度<span class="math inline">\(O(min(k, n))\)</span></p><p>代码 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">LL n, k, p, now, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); LL u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL x, LL k)</span></span>&#123;</span><br><span class="line">LL cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k &amp; <span class="number">1</span>)cnt = cnt * x % p;</span><br><span class="line">x = x * x % p; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"rabit.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"rabit.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">n = read(); k = read(); p = read();</span><br><span class="line">now = <span class="number">2</span> % k; ans = <span class="number">2</span>;</span><br><span class="line">if(!(k &amp; 1))&#123;cout &lt;&lt; ans * ksm(2, n) % p; return 0;&#125;</span><br><span class="line"><span class="keyword">while</span>(now != <span class="number">1</span> &amp;&amp; n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">now = <span class="number">2</span> * now % k;</span><br><span class="line">ans = <span class="number">2</span> * ans % p;</span><br><span class="line">n--;</span><br><span class="line">&#125; <span class="keyword">if</span>(now == <span class="number">1</span>)ans--;</span><br><span class="line">cout &lt;&lt; (ans + p) % p * ksm(2, n) % p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 7 10086</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="t3.高维网络">T3.高维网络</h2><p>题目大意 : 现在有一个<span class="math inline">\(d\)</span>维空间, 起始坐标为<span class="math inline">\(A(0, 0, ...., 0)\)</span>, 结束坐标为<span class="math inline">\(B(a_1, a_2, ...., a_d)\)</span>, 现在有<span class="math inline">\(p\)</span>个坐标上设有障碍, 并且每一步只能在某一个维度上走一步, 也就是说只能这样转移 : <span class="math display">\[(0, 0, ...., 0) -&gt; (1, 0, ...., 0) or (0, 0,...., 0) -&gt; (0, 1, ...., 0)\]</span> 求从起点走到终点不经过障碍有多少种方案, 输出方案数对<span class="math inline">\(P\)</span>取余后的结果</p><p>题解 :</p><p>我们先考虑没有障碍的情况, 从<span class="math inline">\(x(s_1, s_2, ...., s_d)\)</span>移动到<span class="math inline">\(y(t_1, t_2, ...., t_d)\)</span>有多少种方案, 首先我们设数组<span class="math inline">\(tmp_i = t_i - s_i\)</span>, 其后缀和为<span class="math inline">\(S\)</span>, 那么我们一定会走<span class="math inline">\(\sum_{i = 1}^{d}tmp_i\)</span>步, 前<span class="math inline">\(tmp_1\)</span>步我们可以任意分配就有<span class="math inline">\(C_{S_1}^{tmp_1}\)</span>种方案, 然后我们依次分配步数就可以知道方案数为 : <span class="math display">\[Paths(x, y) = \prod_{i = 1} ^ {i \leq d} C_{S_i}^{tmp_i}\]</span> 然后如果直接容斥的话复杂度为<span class="math inline">\(O(2^p \cdot d \cdot logP)\)</span>, 实测可以获得<span class="math inline">\(80\)</span>分的好成绩</p><p>我们现在再考虑<span class="math inline">\(dp\)</span>, <span class="math inline">\(f[i]\)</span>表示从起点到第<span class="math inline">\(i\)</span>个障碍点并且不经过任何障碍点的方案数, 不难得出转移方程为 : <span class="math display">\[f[i] = Paths(A, i) - \sum_{i \ne j} f[j] * Paths(j, i)\]</span> <span class="math inline">\(PS\)</span> :</p><ul><li>注意<span class="math inline">\(Paths(x, y)\)</span>有方向性, 表示从<span class="math inline">\(x\)</span>转移到<span class="math inline">\(y\)</span>可以经过任意障碍的方案数</li><li>并且这个<span class="math inline">\(dp\)</span> 的转移顺序必需是从最靠近起点<span class="math inline">\(A\)</span>的障碍点开始转移, 不然会有问题</li></ul><p><span class="math inline">\(Update\)</span> : 我们来考虑一下这个<span class="math inline">\(dp\)</span>的正确性, 我们可能会想这样<span class="math inline">\(dp\)</span>会不会减掉一些重复的路径, 比如说有三个点<span class="math inline">\(i, j, k\)</span>, <span class="math inline">\(i\)</span>可以到达<span class="math inline">\(j\)</span>, <span class="math inline">\(j\)</span>可以到达<span class="math inline">\(k\)</span>, 在转移的时候我们会将 <span class="math display">\[f[i] * Paths(i, k) \&amp; \&amp; f[j] * Paths(j, k)\]</span> 都减掉, 这样会不会有问题呢?</p><p>实际上是不会的, 我们注意到<span class="math inline">\(f[i]\)</span>的定义是指从<span class="math inline">\(A\)</span>到<span class="math inline">\(i\)</span>号障碍点不经过任何其他障碍的路径方案数, 所以<span class="math inline">\(f[j]\)</span>中的方案数是不包括<span class="math inline">\(f[i] * Paths(i, j)\)</span>的, 所以这样<span class="math inline">\(dp\)</span>的正确性是有保障的, 最终复杂度为<span class="math inline">\(O(p ^ 2 \cdot d \cdot logP)\)</span>这样的复杂度是正确的</p><p>代码 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>], d, p, fac[maxn], s[<span class="number">105</span>], pos[<span class="number">505</span>][<span class="number">105</span>], tmp[<span class="number">105</span>], ans, sum, Q[<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ksm</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k &amp; <span class="number">1</span>)cnt = <span class="number">1l</span>l * cnt * x % P;</span><br><span class="line">x = <span class="number">1l</span>l * x * x % P; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">return</span> cnt % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> *S, <span class="keyword">int</span> *T)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line">tmp[i] = <span class="built_in">abs</span>(T[i] - S[i]);</span><br><span class="line"><span class="keyword">if</span>(S[i] &gt; T[i])<span class="keyword">return</span> zero;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = d; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">s[i] = s[i + <span class="number">1</span>] + tmp[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> C = <span class="number">1</span>;</span><br><span class="line">C = <span class="number">1l</span>l * C * ksm(fac[s[i] - tmp[i]], P - <span class="number">2</span>) % P;</span><br><span class="line">C = <span class="number">1l</span>l * C * ksm(fac[tmp[i]], P - <span class="number">2</span>) % P * fac[s[i]] % P;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * C % P;</span><br><span class="line">&#125; <span class="keyword">return</span> ans % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line"><span class="keyword">if</span>(pos[x][i] != pos[y][i]) <span class="keyword">return</span> pos[x][i] &lt; pos[y][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">freopen(<span class="string">"cube.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"cube.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">d = read(); p = read(); fac[<span class="number">1</span>] = <span class="number">1</span>; fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">sum += (a[i] = read());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sum; i++)</span><br><span class="line">fac[i] = <span class="number">1l</span>l * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">pos[i][j] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)Q[i] = i;</span><br><span class="line">sort(Q + <span class="number">1</span>, Q + <span class="number">1</span> + p, cmp);</span><br><span class="line">ans = calc(pos[<span class="number">0</span>], a);</span><br><span class="line"><span class="comment">//cout &lt;&lt; "ans = " &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">/*for(register int i = 1; i &lt;= p; i++)&#123;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; Q[i] &lt;&lt; " : ";</span></span><br><span class="line"><span class="comment">for(register int j = 1; j &lt;= d; j++)</span></span><br><span class="line"><span class="comment">cout &lt;&lt; pos[Q[i]][j] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)&#123;</span><br><span class="line">f[Q[i]] = calc(pos[<span class="number">0</span>], pos[Q[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; j++)</span><br><span class="line"><span class="keyword">if</span>(Q[i] != Q[j])</span><br><span class="line">f[Q[i]] = (f[Q[i]] - <span class="number">1l</span>l * f[Q[j]] * calc(pos[Q[j]], pos[Q[i]]) % P + P) % P;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "f[" &lt;&lt; Q[i] &lt;&lt; "] = " &lt;&lt; f[Q[i]] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">ans = (ans - <span class="number">1l</span>l * f[i] * calc(pos[i], a) % P + P) % P;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">1 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">2 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="summary">Summary</h2><ul><li>推容斥式子时不要想当然, 想清楚再打</li></ul><p><del>水水水</del></p><p><del>咕咕咕</del></p>]]></content>
      
      <categories>
          
          <category> 模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> DP </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 容斥原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈仙人掌和圆方树</title>
      <link href="/2018/08/31/Cactus/"/>
      <url>/2018/08/31/Cactus/</url>
      <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12wIROa0MTsCi/ZayFJrhxuRv.oNtLHKJRQkdvQ2g0.gm6rjKZHOdZvjM!/r/dDQBAAAAAAAA"> <a id="more"></a></p><h2 id="什么是仙人掌">1.什么是仙人掌</h2><p>给你一张无向图，一条边最多只在一个简单环当中的图被称之为仙人掌，例如：</p><div class="figure"><img src="https://www.lydsy.com/JudgeOnline/images/1023/1.jpg"></div><p><strong>(图片出自BZOJ1023)</strong></p><p>又或者这样</p><div class="figure"><img src="https://images2015.cnblogs.com/blog/795615/201606/795615-20160617203805213-96421613.jpg"></div><p><strong>(图片源于网络)</strong></p><h2 id="什么是圆方树">2.什么是圆方树</h2><p>仙人掌<span class="math inline">\(G = (V, E)\)</span> 的圆方树 <span class="math inline">\(T = (V_T,E_T)\)</span> 为满足以下条件的无向图：</p><ul><li><p><span class="math inline">\(V_T = R_T \bigcup S_T, R_T = V , R_T \bigcap S_T \ne ∅\)</span> , 我们称 <span class="math inline">\(R_T\)</span> 集合为圆点, <span class="math inline">\(S_T\)</span> 集合为方点</p></li><li><p><span class="math inline">\(\large{\forall} {e} \large\in E\)</span> , 若 <span class="math inline">\(e\)</span> 不在任何简单环中, 则<span class="math inline">\(e \large\in E_T\)</span></p></li><li><p>对于每个仙人掌的简单环<span class="math inline">\(R\)</span> ,存在方点<span class="math inline">\(P_R \large\in S_T\)</span> , 并且 <span class="math inline">\(\large{\forall} {p} \large\in R\)</span> 满足<span class="math inline">\((P_R, P) \large\in E_T\)</span> , 即对每个环建立一个方点并连向这个环里的所有点</p></li></ul><p>通俗一点的说 : 就是对于每个简单环都额外建一个方点 , 然后将每个圆点向方点连一条边 , 最后再将不连通的圆点连上原本有的边 , 就构成了圆方树</p><p>以下是对于圆方树正确性的证明：</p><p>感性证明</p><ul><li>不在环上的点和边不会改变其树的性质, 而每个在环上的点都会连向方点, 形成一个菊花图, 所以这一定是一颗树</li></ul><p>理论证明</p><ul><li>原图中的环的个数为 <span class="math inline">\(|E| - |V| + 1\)</span> , 则 <span class="math inline">\(|V_T| = |S_T| + |R_T| = |V| + |E| - |V| + 1 = |E| + 1, |E_T| = |E|\)</span> <strong>(大小为</strong><span class="math inline">\(\textbf{r}\)</span><strong>的环在仙人掌和圆方树中都是</strong><span class="math inline">\(\textbf{r}\)</span><strong>条边)</strong> , 因此满足<span class="math inline">\(|V_T| = |E_T| + 1\)</span></li></ul><h2 id="如何构造圆方树">3.如何构造圆方树</h2><p>我们直接从任意一个点开始进行<span class="math inline">\(Tarjan\)</span> 求点双联通分量 , 然后对于每一个点双联通分量建立一个方点 , 然后连边向这个点双联通分量里的每一个点连边, 最后处理没有连边的圆圆点对</p><p><span class="math inline">\(PS\)</span> : 个人建议通过并查集维护一下连通性在判断是否需要将原图中的边加入进来 , 而且这样可以避免重边带来的一些奇奇怪怪的<span class="math inline">\(bug\)</span></p><p>如图 :</p><div class="figure"><img src="https://images.cnblogs.com/cnblogs_com/cjyyb/1223342/o_qwq.png"></div><p>虚边是原图上的边 , 实边是新建立的圆方树上的边 , 有一些虚边和实边重和的请况可以按照上述并查集的方法来维护</p><h2 id="圆方树的性质">4.圆方树的性质</h2><ul><li><span class="math inline">\(\large{\forall} {(x, y)} \large\in E_T, \{x, y\} \large\cap R_T \ne \varnothing\)</span> , 通俗点说就是两个方点一定不会相连</li><li><p>在构造的过程中无论取什么点为根 , 构造出的圆方树都是一样的(在形态上) , 因此圆方树是无根树 定义 : 子仙人掌 &gt; 以<span class="math inline">\(\textbf{r}\)</span>为根的仙人掌上的点<span class="math inline">\(\textbf{p}\)</span>的子仙人掌是从仙人掌中去掉<span class="math inline">\(\textbf{p}\)</span>到<span class="math inline">\(\textbf{r}\)</span>的简单路径上的所有边之后 , <span class="math inline">\(\textbf{p}\)</span>所在的联通块</p></li><li><p>以<span class="math inline">\(\textbf{r}\)</span>为根的仙人掌中 , 点<span class="math inline">\(\textbf{p}\)</span>的子仙人掌就是圆方树以<span class="math inline">\(\textbf{r}\)</span>为根时点<span class="math inline">\(\textbf{p}\)</span>的子树中的所有圆点所构成的图</p></li></ul><h2 id="利用圆方树和仙人掌解决问题">5.利用圆方树和仙人掌解决问题</h2><h4 id="bzoj4316小c的独立集"><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4316" target="_blank" rel="noopener">BZOJ4316小C的独立集</a></h4><p>题面 : 求一颗仙人掌上的最大独立集</p><p>题解 : 我们先考虑如果在一棵树上应该怎么做 , 考虑状态<span class="math inline">\(f[i][0/1]\)</span>表示这个点选或不选时以这个点为根的子树中的最大独立集是多少 , 那么转移就是 : <span class="math display">\[f[i][0] = \sum_{v \in son[i]}^{v} max(f[v][0], f[v][1]) \\f[i][1] = \sum_{v \in son[i]}^{v} f[v][0]\]</span> 我们再考虑环上如何转移 , 我们把这个环上深度最小的点称作这个环的根 , 我们还是考虑这个环的根选还是不选 , 然后我们把环展开 , 如果选择根节点的话 , 它两侧的点都是不能选的 , 否则就无所谓 , 然后剩下的就按树上的做法来搞就好了 , 所以转移就是 : <span class="math display">\[g[i][0] = max(g[i - 1][0], g[i - 1][1]) + f[id[i]][0] \\g[i][1] = g[i - 1][0] + f[id[i]][1]\]</span></p><p>最后的答案就是<span class="math inline">\(max(f[root][0], f[root][1])\)</span> , 这道题就这么愉悦的水过辣</p><h4 id="bzoj1023cactus仙人掌图"><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1023" target="_blank" rel="noopener">BZOJ1023cactus仙人掌图</a></h4><p>题目大意 : 给你一颗仙人掌 , 求仙人掌上的两点之间最短路的最大值 , 就是仙人掌的直径</p><p>题解 : 我们先考虑在树上怎么做 , 我们考虑状态<span class="math inline">\(f[i]\)</span>表示在以这个点为根的子树当中, 经过<span class="math inline">\(i\)</span>这个点的最长链的长度, 转移很显然, 就是: <span class="math display">\[f[i] = max \{ f[v] + w_{i,v}, v \in son[i] \}\]</span> 然后我们就在转移的过程中更新一下答案就好了</p><p>然后还是一样的思路我们把环单独拎出来搞一下, 但是怎么弄呢, 发现不好在环上直接<span class="math inline">\(dp\)</span>, 因为环上的最短距离是不确定的, 我们考虑把环拆成链, 直接在链上<span class="math inline">\(dp\)</span>, 但是如果直接转移的话是<span class="math inline">\(n^2\)</span>的, 式子是这样的: <span class="math display">\[ans = max(ans, max \{ f[r] + f[l] + r - l, r - l &lt; \frac{len}{2} \} )\]</span> 然后我们观察发现如果固定左端点, 新加入一个右端点我们可以将一些没有当前优的右端点给弹掉, 这个东西是可以用单调队列<span class="math inline">\(O(n)\)</span>维护的, 具体的 :</p><ul><li>如果当前队尾和队头的插值超过环的长度的二分之一, 弹掉队头, 直到符合条件为止</li><li>如果<span class="math inline">\(f[q[tail]] + q[tail] \leq f[i] + i\)</span>, 弹掉队尾, 直到符合条件为止</li></ul><p>然后就可以开心的<span class="math inline">\(dp\)</span>辣</p><h4 id="bzoj2125最短路"><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2125" target="_blank" rel="noopener">BZOJ2125最短路</a></h4><p>题目大意 : 给你一颗仙人掌, 有<span class="math inline">\(n\)</span>次询问, 每次询问两点之间的最短路, <span class="math inline">\(n \leq 10^5\)</span></p><p>题解 : 对于上面的题, 我们可以不用建圆方树, 但是这道题我们考虑将圆方树建出来, 但是有一个问题, 我们怎么设定圆点到方点的边权, 这里有一个小技巧, 我们对于每一个环都建立一个根, 每个圆点到方点的边权就是这个圆点在其所在的环中到这个环的根的最短距离, 这样的话就可以保证从深度小的点向深度大的点遍历时, 是点与点之间的最短距离</p><p>建完图以后, 对其进行倍增预处理, 和剖分, 对于每次查询<span class="math inline">\((u, v)\)</span>, 我们我们求一下<span class="math inline">\(LCA(u, v)\)</span> 如果<span class="math inline">\(LCA(u, v)\)</span>是圆点那么就和普通的树上查询距离是一样的答案就是<span class="math inline">\(dis[u] + dis[v] - dis[LCA(u, v)]\)</span>, 如果是方点的话, 就说明<span class="math inline">\(u, v\)</span>的祖先是在一个环上的, 这种情况不能直接搞, 我们用倍增向上跳到方点下的那个两个点<span class="math inline">\(fa_u, fa_v\)</span>, 让后求一下环上两点的最短距离<span class="math inline">\(L\)</span>,那么最后的答案就是<span class="math inline">\(dis[u] + dis[v] - dis[fa_u] - dis[fa_v] + L\)</span></p><h2 id="广义仙人掌">6.广义仙人掌</h2><p>填坑中.....</p><h2 id="summary">7.Summary</h2><p><del>水水水</del></p><p><del>咕咕咕</del></p>]]></content>
      
      <categories>
          
          <category> OI笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 仙人掌 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 圆方树 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 树链剖分 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EducationalCodeForcesRound48</title>
      <link href="/2018/08/23/EducationalCodeforcesRound48%20/"/>
      <url>/2018/08/23/EducationalCodeforcesRound48%20/</url>
      <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12wIROa0MTsCi/*SVOWpJk1IjRD8HN1cNj094azdOHiadNLhw3R*z*mR8!/r/dPMAAAAAAAAA"> <a id="more"></a></p><h1 id="educational-codeforces-round-48-rated-for-div.-2"><a href="http://codeforces.com/contest/1016" target="_blank" rel="noopener">Educational Codeforces Round 48 (Rated for Div. 2)</a></h1><h2 id="a.death-note"><a href="http://codeforces.com/contest/1016/problem/A" target="_blank" rel="noopener">A.Death Note</a></h2><p>题目大意：告诉你你一天可以写<span class="math inline">\(a_i\)</span>个字, 现在你有一本<span class="math inline">\(DeathNote\)</span>,这本书有<span class="math inline">\(n\)</span>页,每页可以写<span class="math inline">\(m\)</span>个字，问每天如果写<span class="math inline">\(a_i\)</span>个字的话,一天要翻多少页</p><p>题解：你搞一个 <span class="math inline">\(sum\)</span> 记录当前页你已经写了多少个字，然后每天要翻的页数就是$ $, <span class="math inline">\(sum = (sum + a_i)\%m\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], n, m, ans;</span><br><span class="line"></span><br><span class="line">LL sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(); m = read(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)a[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">sum += a[i]; ans = sum / m;</span><br><span class="line"><span class="comment">//while(sum &gt;= m)ans++, sum -= m;</span></span><br><span class="line">sum %= m;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b.segment-occurrences"><a href="http://codeforces.com/contest/1016/problem/B" target="_blank" rel="noopener">B.Segment Occurrences</a></h2><p>题目大意：给你一个串<span class="math inline">\(s_0\)</span> , 再给你一个匹配串<span class="math inline">\(s_1\)</span> ,有<span class="math inline">\(m\)</span>次询问每次问你<span class="math inline">\(s_0\)</span>这个串在<span class="math inline">\([l, r]\)</span>这个区间内，出现了多少次<span class="math inline">\(s_1\)</span>串</p><p>题解：由于<span class="math inline">\(len(s_1) \leq 10^3\)</span> , <span class="math inline">\(len(s_0) \leq 10^5\)</span> ,所以我们直接对于<span class="math inline">\(s_0\)</span>中的每一位的后<span class="math inline">\(len(s_1)\)</span>位和<span class="math inline">\(s_1\)</span>匹配一下，然后<span class="math inline">\(a_i = (s_1==s_{0l, r})\)</span> ，用这个数组搞一下前缀和，每次之久<span class="math inline">\(O(1)\)</span>查询就好了,但是注意如果查询<span class="math inline">\([l,r]\)</span>区间最后的答案是<span class="math inline">\(sum[r - len(s_1) + 1] - sum[l - 1]\)</span>而不是<span class="math inline">\(sum[r]-sum[l-1]\)</span>,然后匹配我用的是哈希，当然<span class="math inline">\(KMP\)</span>, 暴力匹配都是可以的</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seed0 = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seed1 = <span class="number">23331</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Q, sum[maxn], n, m;</span><br><span class="line"><span class="keyword">char</span> s[maxn], s1[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hash</span>&#123;</span></span><br><span class="line">ull base0, base1;</span><br><span class="line">Hash(ull X = <span class="number">0</span>, ull X0 = <span class="number">0</span>)&#123;base0 = X; base1 = X0;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Hash &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> base0 == t.base0 &amp;&amp; base1 == t.base1;&#125;</span><br><span class="line">&#125;ex, op[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Hash <span class="title">gethash</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len, <span class="keyword">char</span> *s)</span></span>&#123;</span><br><span class="line">ull base0 = <span class="number">0</span>, base1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = pos; i &lt;= pos + len - <span class="number">1</span>; i++)</span><br><span class="line">base0 = base0 * seed0 + s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = pos; i &lt;= pos + len - <span class="number">1</span>; i++)</span><br><span class="line">base1 = base1 * seed1 + s[i];</span><br><span class="line"><span class="keyword">return</span> Hash(base0, base1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(); m = read(); Q = read();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s + <span class="number">1</span>, s1 + <span class="number">1</span>);</span><br><span class="line">ex = gethash(<span class="number">1</span>, m, s1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i + m - <span class="number">1</span> &lt;= n; i++)&#123;</span><br><span class="line">op[i] = gethash(i, m, s);</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + (op[i] == ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> l = read(), r = read();</span><br><span class="line"><span class="keyword">if</span>(r - l + <span class="number">1</span> &lt; m)<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum[r - m + <span class="number">1</span>] - sum[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c.vasya-and-the-mushrooms"><a href="http://codeforces.com/contest/1016/problem/C" target="_blank" rel="noopener">C.Vasya And The Mushrooms</a></h2><p>题目大意：有两排蘑菇，每行有<span class="math inline">\(n\)</span>个，每个蘑菇都有一个生长速度<span class="math inline">\(a_i\)</span>, 一开始的初始时间是零，你在两个个子之间移动的速度是<span class="math inline">\(1m/s\)</span> 每个相邻的格子之间的距离是一，最后你得到每个蘑菇的权值是<span class="math inline">\(a_i\cdot t_i\)</span> ，<span class="math inline">\(t_i\)</span>是你猜到这个蘑菇的时间，问你如何采摘才能让总权值最大</p><p>题解：这题然我们一次性拿完并且不能经过相同的蘑菇，那么很显然如果你在某一行上走的路径长度超过二的话那么你就必须得走到头然后从另一行绕回来，那么我们就可以枚举一下是从那一行的哪一列开始一直向前走的，此前我们必须得走蛇形的，例如：</p><div class="figure"><img src="http://r.photo.store.qq.com/psb?/V12wIROa4RmSjE/rUFSkozPDhUPV*4kyF3fEwrJv6AJqUhl0Q5sqW.Q.XI!/r/dDYBAAAAAAAA"></div><p>所以我们枚举一下转折点就好了，关于统计答案我们处理一个蛇行走的第一行和第二行的前缀和(就是在蛇行走时的前缀和)分别为 <span class="math inline">\(s_0, s_1\)</span>，和一个前缀和分别为<span class="math inline">\(ss_0, ss_1\)</span>，和一个后缀和<span class="math inline">\(sss_0, sss_1\)</span>，还有一个这样的东西 <span class="math display">\[ssa_{i} = \sum_{j=1}^{j\leq i}i\cdot a_j\]</span> 和这样一个东西 <span class="math display">\[ssb_{1i}=\sum_{j=i}^{j \leq n}(n - j + 1) \cdot a_j\]</span> 所以说对于一个转折点在第一行第<span class="math inline">\(i\)</span>列的情况来说 <span class="math display">\[ans = s_{0i} + s_{1i} + (sum_{0n} - sum_{0i} + i \cdot (ss_{0n} - ss_{0i})) + (ssb_{1i} - ssb_{1n} + (n + i) \cdot (sss_{1i} - sss_{1n}))\]</span> 还有一个是就是转折点在第二行第<span class="math inline">\(i\)</span>列的情况，我就不打了，写着好麻烦，见代码，<del>其实就是懒</del></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seed0 = <span class="number">233</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> seed1 = <span class="number">23331</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line">LL ans, sum, sa[maxn], sb[maxn], ssa0[maxn], ssb0[maxn], ssa1[maxn], ssb1[maxn], s0[maxn], s1[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">s0[i] = s0[i - <span class="number">1</span>] + (a[i] = read());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">s1[i] = s1[i - <span class="number">1</span>] + (b[i] = read());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">ssb0[i] = ssb0[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">ssa1[i] = ssa1[i + <span class="number">1</span>] + <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">ssa0[i] = ssa0[i - <span class="number">1</span>] + <span class="number">1l</span>l * i * a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">ssb1[i] = ssb1[i + <span class="number">1</span>] + <span class="number">1l</span>l * (n - i + <span class="number">1</span>) * b[i];</span><br><span class="line">ans = max(ans, sum);</span><br><span class="line"><span class="comment">// -------------------------------------------------- // task 3</span></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, tim = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>, tim += <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt;= n)sb[i] = sb[i - <span class="number">1</span>] + <span class="number">1l</span>l * tim * b[i];</span><br><span class="line"><span class="keyword">if</span>(i &lt; n)sb[i + <span class="number">1</span>] = sb[i] + <span class="number">1l</span>l * (tim + <span class="number">1</span>) * b[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>, tim = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>, tim += <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt;= n)sa[i] = sa[i - <span class="number">1</span>] + <span class="number">1l</span>l * tim * a[i];</span><br><span class="line"><span class="keyword">if</span>(i &lt; n)sa[i + <span class="number">1</span>] = sa[i] + <span class="number">1l</span>l * (tim + <span class="number">1</span>) * a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">sum = <span class="number">0</span>; <span class="keyword">int</span> tim = (i - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">sum += sa[i - <span class="number">1</span>] + sb[i - <span class="number">1</span>];</span><br><span class="line">sum += (ssa0[n] - ssa0[i - <span class="number">1</span>]) + <span class="number">1l</span>l * (tim - i) * (s0[n] - s0[i - <span class="number">1</span>]);</span><br><span class="line">sum += ssb1[i] + <span class="number">1l</span>l * (tim + n - i) * (s1[n] - s1[i - <span class="number">1</span>]);</span><br><span class="line">ans = max(ans, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">sum = <span class="number">0</span>; <span class="keyword">int</span> tim = i * <span class="number">2</span>; </span><br><span class="line">sum += sa[i] + sb[i];</span><br><span class="line">sum += (ssb0[n] - ssb0[i]) + <span class="number">1l</span>l * (tim - i - <span class="number">1</span>) * (s1[n] - s1[i]);</span><br><span class="line">sum += ssa1[i + <span class="number">1</span>] + <span class="number">1l</span>l * (tim + n - i - <span class="number">1</span>) * (s0[n] - s0[i]);</span><br><span class="line">ans = max(ans, sum);</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d.vasya-and-the-matrix"><a href="http://codeforces.com/contest/1016/problem/D" target="_blank" rel="noopener">D.Vasya And The Matrix</a></h2><p>题目大意：给你一个<span class="math inline">\(n \cdot m\)</span>的矩阵，告诉你每一行和每一列的异或和，让你求出一种合法解</p><p>题解：我们考虑直接对前<span class="math inline">\(n-1\)</span>行只填第一个数，这个数等于每一行的异或和，也就是说前<span class="math inline">\(n-1\)</span></p><p>的每一行的后<span class="math inline">\(m-1\)</span>列都填零，最后一行的第一个数等于第一列的异或和异或上第一列的前<span class="math inline">\(n-1\)</span>行的每一个数</p><p>然后对于最后一行的后<span class="math inline">\(m-1\)</span>个数都填的是对应的每一列的异或和，如果最后一行的所有数异或起来不等于最后一行的异或和就是无解，否则就是就是合法解</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, c[maxn], r[maxn], mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> cnow[maxn], rnow[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; (((1 &lt;&lt; 30) - 1) &lt;&lt; 1) + 1; 2147483647</span></span><br><span class="line">n = read(); m = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)c[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)r[i] = read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">mp[i][<span class="number">1</span>] = c[i], rnow[<span class="number">1</span>] ^= c[i];</span><br><span class="line">mp[n][<span class="number">1</span>] = rnow[<span class="number">1</span>] ^ r[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++)</span><br><span class="line">mp[n][i] = r[i], cnow[n] ^= r[i];</span><br><span class="line"><span class="keyword">if</span>((cnow[n] ^ mp[n][<span class="number">1</span>]) != c[n])<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mp[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e.rest-in-the-shades"><a href="http://codeforces.com/contest/1016/problem/E" target="_blank" rel="noopener">E.Rest In The Shades</a></h2><p>题目大意：已知一个光源的纵坐标与横坐标的变化范围，现在<span class="math inline">\(x\)</span>轴上有<span class="math inline">\(n\)</span>条围栏(会挡住光线)，并且第一象限中有<span class="math inline">\(q\)</span>个点，问你点在起点移动到终点的过程中<span class="math inline">\(q\)</span>个点中每个点处于阴影的时间。<span class="math inline">\(PS\)</span>:光源的移动速度为<span class="math inline">\(1\)</span>单位每秒，</p><p>并且保证线段不相交</p><p>题解：我们换一种方法理解一下这个题目，其实这个题目要求的东西可以转化为，<span class="math inline">\(q\)</span>个点中每个点和每条线段的左右端点连线后在光源的纵坐标的位置会得到<span class="math inline">\(n\)</span>个投影，然后问这<span class="math inline">\(n\)</span>个投影和光源移动的那个线段的重合部分有多长，因为我们得到的是<span class="math inline">\(n\)</span>个不相交的投影，所以我们直接离散一下值域，然后二分一下光源移动的线段的左端点与右端点，把处于这个范围中间的完整的投影加上，再算一下两端不完全重合的投影所覆盖的长度即可，如图：</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">double</span> l, r;&#125;t[maxn];</span><br><span class="line"><span class="keyword">double</span> sum[maxn], y2, L, R;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lower</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(t[mid].l &gt; x)r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">equ</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>(x - y) &lt;= eps;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">getpos</span><span class="params">(<span class="keyword">double</span> x2, <span class="keyword">double</span> y2, <span class="keyword">double</span> x3, <span class="keyword">double</span> y3)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> k = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(equ(x2, x3))<span class="keyword">return</span> x2;</span><br><span class="line">k = (y2 - y3) / (x2 - x3); b = y2 - k * x2;</span><br><span class="line"><span class="keyword">return</span> -b / k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; (((1 &lt;&lt; 30) - 1) &lt;&lt; 1) + 1; 2147483647</span></span><br><span class="line">y2 = read(); L = read(); R = read(); n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">t[i].l = read(); t[i].r = read();</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + t[i].r - t[i].l;</span><br><span class="line">&#125; Q = read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">0</span>, x = read(), y = read(), ans = <span class="number">0</span>;</span><br><span class="line">l = getpos(x, y, L, y2); r = getpos(x, y, R, y2);</span><br><span class="line"><span class="keyword">int</span> posl = lower(<span class="number">0</span>, n, l), posr = lower(<span class="number">0</span>, n, r);</span><br><span class="line"><span class="keyword">if</span>(posr == <span class="number">0</span>)ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*ans = min(r, max(l, t[posl].r)) - t[posl].l - fabs(l - t[posl].l);</span></span><br><span class="line"><span class="comment">if(posr &gt; posl)&#123;</span></span><br><span class="line"><span class="comment">ans += max(r, t[posr].r) - t[posr].l - fabs(r - t[posr].r);</span></span><br><span class="line"><span class="comment">ans += sum[posr - 1] - sum[posl];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">ans = sum[posr - <span class="number">1</span>] - sum[posl - <span class="number">1</span>];</span><br><span class="line">ans -= (min(l, t[posl].r) - t[posl].l);</span><br><span class="line">ans += max(r, t[posr].r) - t[posr].l - <span class="built_in">fabs</span>(r - t[posr].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.15lf\n"</span>, ans * (y - y2) / y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f.road-projects"><a href="http://codeforces.com/contest/1016/problem/F" target="_blank" rel="noopener">F.Road Projects</a></h2><p>题目大意：给你一棵树，有<span class="math inline">\(m\)</span>个询问，每个询问有一个<span class="math inline">\(x\)</span>,问你再这棵树上的任意两个没有直接的遍相连的节点中间加上一条边权为 <span class="math inline">\(v\)</span> 的边，从<span class="math inline">\(1\)</span>号结点到<span class="math inline">\(n\)</span>号节点的路径上边权和的最小值最大可以为多少</p><p><del>原题题面写的真TM辣鸡，又扯又说不清</del></p><p>题解：考虑这样一个事实，无论加的边的权值是多少我们每次都贪心选取相同的两个节点来加边肯定是最优的。</p><p>那么怎么求这一对节点呢，我们可以设<span class="math inline">\(d_1[x]\)</span>为<span class="math inline">\(1\)</span>号结点到<span class="math inline">\(x\)</span>号节点的权值，<span class="math inline">\(d_n[x]\)</span>为<span class="math inline">\(n\)</span>号节点到<span class="math inline">\(x\)</span>号结点的权值，如果在<span class="math inline">\(x,y\)</span>中间加了一条边 <span class="math display">\[ans = min(d_1[n], min(d_1[x]+v+d_n[y],d_1[y]+v+d_n[x]))\]</span> 如果<span class="math inline">\(d_1[x]+v+d_n[y] \leq d_1[y]+v+d_n[x]\)</span> 等价于 <span class="math inline">\(d_1[x] - d_n[x] \leq d_1[y]-d_n[y]\)</span> ,所以我们直接按照这个为比较的依据把所有的点都丢进一个<span class="math inline">\(vector\)</span>中，然后<span class="math inline">\(sort\)</span>一下，再呗所有点都丢进一个<span class="math inline">\(set\)</span>中，这回用 <span class="math inline">\(d_n[x]\)</span> 做为排序依据，然后顺序枚举一下，每个节点求一个相对于这个节点最优另一个节点即<span class="math inline">\(set.end() - 1\)</span>等价于<span class="math inline">\(set.rbegin()\)</span>(反向迭代器),</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> LL inf = (<span class="number">1l</span>l &lt;&lt; <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, head[maxn], pos[maxn];</span><br><span class="line">LL d1[maxn], dn[maxn], minv = inf, maxv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span><span class="keyword">int</span> to, nt, w;&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;LL, <span class="keyword">int</span>&gt; &gt;o;</span><br><span class="line"><span class="built_in">set</span>&lt;pair&lt;LL, <span class="keyword">int</span>&gt; &gt;s0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ini</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span>&#123;e[++cnt] = (Graph)&#123;y, head[x], w&#125;; head[x] = cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa, LL *d, LL dis)</span></span>&#123;</span><br><span class="line">d[now] = dis;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = head[now]; i; i = e[i].nt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(v == fa)<span class="keyword">continue</span>;</span><br><span class="line">dfs(v, now, d, dis + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(); m = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = read(), y = read(), w = read();</span><br><span class="line">ini(x, y, w); ini(y, x, w);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">1</span>, d1, <span class="number">0</span>); dfs(n, n, dn, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">o.push_back(make_pair(d1[i] - dn[i], i));</span><br><span class="line">sort(o.begin(), o.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">pos[o[i].second] = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">s0.insert(make_pair(dn[i], i));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; o.size(); i++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = o[i].second;</span><br><span class="line">s0.erase(make_pair(dn[p], p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> u = head[p]; u; u = e[u].nt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[u].to;</span><br><span class="line"><span class="keyword">if</span>(pos[v] &gt; pos[p])</span><br><span class="line">s0.erase(make_pair(dn[v], v));</span><br><span class="line">&#125;</span><br><span class="line">LL p0 = inf;</span><br><span class="line"><span class="keyword">if</span>(!s0.empty())</span><br><span class="line">maxv = max(maxv, s0.rbegin() -&gt; first + d1[p]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> u = head[p]; u; u = e[u].nt)&#123;</span><br><span class="line"><span class="keyword">int</span> v = e[u].to;</span><br><span class="line"><span class="keyword">if</span>(pos[v] &gt; pos[p])</span><br><span class="line">s0.insert(make_pair(dn[v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x = read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(d1[n], maxv + x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="g.appropriate-team"><a href="http://codeforces.com/contest/1016/problem/G" target="_blank" rel="noopener">G.Appropriate Team</a></h2><p>题目大意：给你一个值域为<span class="math inline">\(10^{18}\)</span>的序列<span class="math inline">\(a\)</span>, 和一个<span class="math inline">\(X,Y\)</span>，问你有多少对<span class="math inline">\(i,j\)</span>满足存在一个<span class="math inline">\(V\)</span>, 使 <span class="math display">\[GCD(a_i,V) = X, LCM(a_j,V)=Y\]</span> 特别的<span class="math inline">\(i,j\)</span>可以相等</p><p>题解：由题意可知 $ V % X == 0, Y % V == 0 $ 所以如果<span class="math inline">\(Y \% X \neq 0\)</span>则不存在<span class="math inline">\(V\)</span>即<span class="math inline">\(ans=0\)</span></p><p>否则 <span class="math display">\[X = \prod P_{i}^{p_{xi}}, Y = \prod P_{i}^{p_{yi}}, a_j = \prod P_{i}^{p_{aji}}\]</span> 对于 <span class="math inline">\(GCD(x,y)\)</span> 是将每个<span class="math inline">\(x,y\)</span> 的素因子的个数取个<span class="math inline">\(min\)</span> 即 <span class="math display">\[GCD(x,y) = \prod P_i^{min(P_{xi}, P_{yi})}\]</span> 而<span class="math inline">\(LCM(x,y)\)</span>　则是取<span class="math inline">\(max\)</span> <span class="math display">\[LCM(x,y) = \prod P_i^{max(P_{xi}, P_{yi})}\]</span> 也就说如果对于<span class="math inline">\(GCD(a_i,V)\)</span>的一个素因子<span class="math inline">\(P_i\)</span>来说，如果<span class="math inline">\(P_{ai} &gt; P_{xi}\)</span>, 那么<span class="math inline">\(P_{Vi} = P_{xi}\)</span>, 否则就无所谓</p><p>反过来如果对于<span class="math inline">\(LCM(a_j,V)\)</span>的一个素因子<span class="math inline">\(P_i\)</span>来说，如果 <span class="math inline">\(P_{ai} &lt; P_{yi}\)</span>,那么<span class="math inline">\(P_{Vi}=P_{yi}\)</span>。</p><p>至此我们可以这样看，对于每一个素因子<span class="math inline">\(P_i\)</span>,设<span class="math inline">\(l=P_{xi},r=P_{yi}\)</span> 如果<span class="math inline">\(P_{ai}==l||P_{aj}==r\)</span>则存在这样的一个素因子, 特别的如果<span class="math inline">\(l==r\)</span>也一定会存在一个这样的素因子，当对于每一个素因子都成立时就存在一个<span class="math inline">\(V\)</span>, 因为一个值域为<span class="math inline">\(10^{18}\)</span>的数，至多有<span class="math inline">\(15\)</span>个<strong>不同</strong>的素因子, 所以我们可以直接搞一个二进制来表示一下对于每个素因子的状态，我们这样表示，如果对于一个素因子成立就把这一位设为<span class="math inline">\(1\)</span>，所以对于每个<span class="math inline">\(a_i\)</span>他都有两个二进制<span class="math inline">\(l_i\)</span>和<span class="math inline">\(r_i\)</span>,最后要我们求的问题就可以转化为，从一个序列中取<span class="math inline">\(i,j\)</span>使得<span class="math inline">\(l_i|r_j==(1&lt;&lt;15)-1\)</span>,但这样表示不太好看我们把不成立设为<span class="math inline">\(1\)</span>, 最后就是<span class="math inline">\(l_i \&amp; r_i==0\)</span> , 最后就是怎么算，官方题解给的是<span class="math inline">\(n\cdot2^n\)</span>，但是我并不会。<del>我太菜辣</del></p><p>最后就是关于<span class="math inline">\(X,Y\)</span>的素因数的分解，这里我用的是<span class="math inline">\(Pollard-rho\)</span>算法，由于数据很毒瘤，这里一定要用龟速乘才能过，不然会爆</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">LL minv[<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line">LL numx[<span class="number">15</span>], numy[<span class="number">15</span>];</span><br><span class="line">LL n, a[maxn], x, y, A, B, facy[<span class="number">15000</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar(); LL u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span></span>&#123;<span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL x, LL y, LL p)</span></span>&#123;</span><br><span class="line">    LL cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>)cnt = (cnt + x) % p;</span><br><span class="line">        x = (x + x) % p; y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL x, LL k, LL p)</span></span>&#123;</span><br><span class="line">    LL cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>)cnt = mul(cnt, x, p);</span><br><span class="line">        x = mul(x, x, p); k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">(LL a, LL p)</span></span>&#123;</span><br><span class="line">    LL q = p - <span class="number">1</span>; <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        ++k, q &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    LL v = ksm(a, q, p);</span><br><span class="line">    <span class="keyword">if</span>(v == <span class="number">1</span> || v == p - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(k-- != <span class="number">0</span>)&#123;</span><br><span class="line">        v = mul(v, v, p);</span><br><span class="line">        <span class="keyword">if</span>(v == p - <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabbin</span><span class="params">(LL p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p % <span class="number">2</span> == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++)&#123;</span><br><span class="line">        LL a = rand() % (p - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(judge(a, p))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">pollard_rho</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    LL x = <span class="number">0</span>, y = x, t = <span class="number">1</span>, q = <span class="number">1</span>, a = (rand() % (n - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>;; k &lt;&lt;= <span class="number">1</span>, y = x, q = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            x = (mul(x, x, n) + a) % n;</span><br><span class="line">            q = mul(q, <span class="built_in">abs</span>(x - y), n);</span><br><span class="line">            <span class="keyword">if</span> (!(i &amp; M)) &#123;</span><br><span class="line">                t = gcd(q, n);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span> || (t = gcd(q, n)) &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == n) &#123;</span><br><span class="line">        t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t == <span class="number">1</span>) t = gcd(<span class="built_in">abs</span>((x = ((mul(x, x, n) + a) % n)) - y), n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">findfac</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(miller_rabbin(x))&#123;facy[++facy[<span class="number">0</span>]] = x; <span class="keyword">return</span>;&#125;</span><br><span class="line">    LL p = x;</span><br><span class="line">    <span class="keyword">while</span>(p &gt;= x)p = pollard_rho(p);</span><br><span class="line">    findfac(p);</span><br><span class="line">    findfac(x / p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 133056495 897612484786617600</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dEBUG</span><span class="params">(LL *x, LL len)</span></span>&#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"----------------------------------DEBUG----------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++)</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; x[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"----------------------------------DEBUG----------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">19260817</span>);</span><br><span class="line">n = read(); A = x = read(); B = y = read();</span><br><span class="line"><span class="keyword">if</span>(y % x != <span class="number">0</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)a[i] = read();</span><br><span class="line">    findfac(B);</span><br><span class="line">    sort(facy + <span class="number">1</span>, facy + <span class="number">1</span> + facy[<span class="number">0</span>]);</span><br><span class="line">    facy[<span class="number">0</span>] = unique(facy + <span class="number">1</span>, facy + <span class="number">1</span> + facy[<span class="number">0</span>]) - facy - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= facy[<span class="number">0</span>]; i++)</span><br><span class="line"><span class="keyword">while</span>(B % facy[i] == <span class="number">0</span>)B /= facy[i], numy[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= facy[<span class="number">0</span>]; i++)</span><br><span class="line"><span class="keyword">while</span>(A % facy[i] == <span class="number">0</span>)A /= facy[i], numx[i]++;</span><br><span class="line"><span class="comment">//dEBUG(facy, facy[0]);</span></span><br><span class="line"><span class="comment">//dEBUG(numx, facy[0]);</span></span><br><span class="line"><span class="comment">//dEBUG(numy, facy[0]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] % x != <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> maskx = <span class="number">0</span>; LL T = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= facy[<span class="number">0</span>]; k++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(numx[k] == numy[k])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">while</span>(T % facy[k] == <span class="number">0</span>)T /= facy[k], p++;</span><br><span class="line">maskx |= ((p &gt; numx[k]) &lt;&lt; (k - <span class="number">1</span>));</span><br><span class="line">&#125; minv[maskx]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; facy[<span class="number">0</span>]; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> G = <span class="number">0</span>; G &lt; (<span class="number">1</span> &lt;&lt; facy[<span class="number">0</span>]); G++)</span><br><span class="line"><span class="keyword">if</span>(G &amp; (<span class="number">1</span> &lt;&lt; i))minv[G] += minv[G ^ (<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line"><span class="keyword">int</span> MK = (<span class="number">1</span> &lt;&lt; facy[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(y % a[i] != <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> masky = <span class="number">0</span>; LL T = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= facy[<span class="number">0</span>]; k++)&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(T % facy[k] == <span class="number">0</span>)T /= facy[k], p++;</span><br><span class="line">masky |= ((p &lt; numy[k]) &lt;&lt; (k - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">ans += minv[masky ^ MK];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dEBUG(minv, n); dEBUG(maxv, n);</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Summary</strong>:读懂题目很重要，打代码之前想清楚为什么，不要不懂装懂，打完就完事了</p><p><strong><em>Thinck Twice, Code once.</em></strong></p>]]></content>
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> Hash </tag>
            
            <tag> KMP </tag>
            
            <tag> Greedy </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> Pollard-rho </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF_Round499(Div.2)</title>
      <link href="/2018/07/31/CodeforcesRound499(Div.2)/"/>
      <url>/2018/07/31/CodeforcesRound499(Div.2)/</url>
      <content type="html"><![CDATA[<p><img src="http://r.photo.store.qq.com/psb?/V12wIROa0MTsCi/J0RvZndfXntDHHLATTq4z3BasJgRnYqMjneN8CqRnfk!/r/dGEBAAAAAAAA"> <a id="more"></a></p><h1 id="codeforces-round-499-div.2"><a href="https://codeforc.es/contest/1011" target="_blank" rel="noopener">Codeforces Round #499 (Div.2)</a></h1><h2 id="a.-stages">A. <a href="https://codeforc.es/contest/1011/problem/A" target="_blank" rel="noopener">Stages</a></h2><p>题目大意：给你一个长度为<span class="math inline">\(n\)</span>的字符串， 让你从其中拿出<span class="math inline">\(k\)</span>个字符， 要求权值最小， 并且拿出的<span class="math inline">\(k\)</span>个字符中，至少要有一个间隔</p><p>题解： 直接将字符串<span class="math inline">\(sort\)</span>一下就好了，每次间隔一个取， 如果能取足<span class="math inline">\(k\)</span>个那么就是满足条件的，否则就输出<span class="math inline">\(-1\)</span></p><p>PS : 这里的间隔取不是指的字母在序列中的位置，而是在<span class="math inline">\(26\)</span>个字母中的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, ans;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;k, s + <span class="number">1</span>);</span><br><span class="line">sort(s + <span class="number">1</span>, s + <span class="number">1</span> + n); <span class="keyword">int</span> p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k &amp;&amp; p &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[p] - s[l] &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">ans += s[p] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">k--; l = p;</span><br><span class="line">&#125; p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k)<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b.-planning-the-expedition">B. <a href="https://codeforc.es/contest/1011/problem/B" target="_blank" rel="noopener">Planning The Expedition</a></h2><p>题目大意： 你有一些物品，每个物品都只有若干个，有<span class="math inline">\(n\)</span>个人， 每个人只能吃同种物品，并且每天只吃一个，问你<span class="math inline">\(n\)</span>个人最多能吃几天</p><p>题解： 我们考虑直接二分一个天数<span class="math inline">\(mid\)</span>，线性扫描所有物品，每种物品的数量<span class="math inline">\(k_i\)</span>, 有<span class="math inline">\(m\)</span>种物品，则<span class="math inline">\(cnt = \sum_{i=1}^m\lfloor \frac{k_i}{mid} \rfloor\)</span>, 如果最后<span class="math inline">\(n\)</span> <span class="math inline">\(\leq\)</span> <span class="math inline">\(cnt\)</span>，就成立，否则不成立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn], bac[maxn], tmp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">x -= bac[i] / mid;</span><br><span class="line"><span class="keyword">return</span> x &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read(); m = read();</span><br><span class="line"><span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)bac[a[i] = read()]++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; binary(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c.-fly">C. <a href="https://codeforc.es/contest/1011/problem/C" target="_blank" rel="noopener">Fly</a></h2><p>题目大意： 你有一架飞机，质量为<span class="math inline">\(m\)</span>, 要求从<span class="math inline">\(1\)</span>好星球飞到<span class="math inline">\(n\)</span>星球, 在每个星球起飞或者降落都有一个系数<span class="math inline">\(k_i\)</span>, 起飞的耗油量为起飞前飞机质量和油的质量的和除以<span class="math inline">\(k_i\)</span>, 问你最少需要带多少油</p><p>题解： 再次考虑二分答案， 直接按照题目的意思模拟一下，判断最后的剩余的质量是否大于飞机的质量<span class="math inline">\(m\)</span></p><p>PS: 注意精度问题, <span class="math inline">\(eps = 1e-8\)</span>即可， 否则会可能会<span class="math inline">\(T\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> m, a[maxn], b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> now = m + mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">now -= now / a[i];</span><br><span class="line">now -= now / b[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">now -= now / a[n];</span><br><span class="line">now -= now / b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> now + eps &gt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r + eps)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid))r = mid - eps, ans = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + eps;</span><br><span class="line">&#125; <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;b[i]);</span><br><span class="line"><span class="keyword">if</span>(b[i] &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, binary(<span class="number">0</span>, <span class="keyword">double</span>(inf)));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d.-rocket">D. <a href="https://codeforc.es/contest/1011/problem/D" target="_blank" rel="noopener">Rocket</a></h2><p>题目大意：一道交互题， 要你猜一个数字<span class="math inline">\(x\)</span><span class="math inline">\((x \leq m)\)</span>， <span class="math inline">\(m\)</span>给出，并且回答机制是一种循环， 我们知道这个循环的长度为<span class="math inline">\(n\)</span><span class="math inline">\((n \leq 30)\)</span>, 这个序列是一个<span class="math inline">\(01\)</span>序列， 如果是<span class="math inline">\(0\)</span>那么回答的就是假话，是<span class="math inline">\(1\)</span>回答的就是真话，要求最多询问六十次，求出这个数字</p><p>题解： 首先我们可以用<span class="math inline">\(n\)</span>次询问确定这个<span class="math inline">\(01\)</span>序列，然后再用剩余询问次数确定这个数字，我们的前<span class="math inline">\(n\)</span>次询问每次都问<span class="math inline">\(m\)</span>, 如果问答大于就是说谎， 否则就是真话， 那么通过<span class="math inline">\(n\)</span>次询问，<span class="math inline">\(01\)</span>序列就确定下来了，然后就是普通的二分了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (a[(tot % n == <span class="number">0</span>) ? n : tot % n] == <span class="number">0</span>) t = -t;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">-1</span>)a[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = m, mid = (l + r) / <span class="number">2</span>, tot = n;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> t = check(mid, ++tot);</span><br><span class="line"><span class="keyword">if</span>(t == <span class="number">-1</span>) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e.-border">E. <a href="https://codeforc.es/contest/1011/problem/E" target="_blank" rel="noopener">Border</a></h2><p>题目大意：我们有<span class="math inline">\(n\)</span>种物品，每种物品都有一个价值<span class="math inline">\(val_i\)</span>, 并且都可以无限选择，问你在模<span class="math inline">\(k\)</span>的意义下能够组成多少种不同的价值, 输出种类数， 并且输出方案</p><p>题解：由<span class="math inline">\(n\)</span>个数的斐蜀定理可知，<span class="math inline">\(\sum_{i=1}^n a_ix_i = p \cdot gcd \{ x_i\}\)</span> , 假如我们有三个物品 <span class="math inline">\(a_1x_1 + a_2x_2 +a_3x_3 = p\cdot gcd\{x_1, x_2, x_3\}\)</span> , 这里的<span class="math inline">\(a_i\)</span>可以为负数，但是题目中必须得选非负数个那我们转换一下</p><p><span class="math inline">\(a_1x_1 +a_2x_2 +a_3x_3\)</span> 和 <span class="math inline">\(a_1x_1 + a_2x_2 + a_3x_3 + a_1&#39; \cdot kx_1 + a_2&#39; \cdot kx_2 + a_3&#39; \cdot kx_3\)</span> 在模<span class="math inline">\(k\)</span> 的意义下是一样的所以这个定理在模意义下是可以用的， 所以本题就很简单了，答案就是<span class="math inline">\(t \cdot gcd\{x_i\}, t \in [0,n]\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = read(); k = read(); t = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        t = gcd(t, read());</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        st.insert((i * t) % k);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; st.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator iter = st.begin(); iter != st.end(); iter++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f.-mars-rover">F. <a href="https://codeforc.es/contest/1011/problem/F" target="_blank" rel="noopener">Mars rover</a></h2><p>题目大意：我们有一棵二叉树，在所有的非叶子节点上有一个二进制运算符，由每个叶子节点向上合并到根节点可以得到一个值，问你修改每一个叶子节点的值时最后的答案是多少(每个叶子节点的权值都是<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>)，</p><p>题解：一遍<span class="math inline">\(dfs\)</span>求出一开始的答案，再用一次<span class="math inline">\(dfs\)</span>求出每次修改一个节点的权值会不会影响答案，关键是第二次<span class="math inline">\(dfs\)</span>怎么写，我们考虑除了&quot;与&quot;和&quot;或&quot;其他的二进制运算符只要改变其儿子节点的权值就会改变自己的权值，既然知道了这一点我们特判一下就好了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, ch[maxn][<span class="number">2</span>], ok[maxn], w[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch = getchar(); <span class="keyword">int</span> u = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))&#123;u = u * <span class="number">10</span> + ch - <span class="number">48</span>; ch = getchar();&#125; <span class="keyword">return</span> u * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> x0, <span class="keyword">int</span> x1)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(s[now][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> x0 &amp; x1;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'O'</span>: <span class="keyword">return</span> x0 | x1;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> x0 ^ x1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(~w[now])<span class="keyword">return</span> w[now];</span><br><span class="line"><span class="keyword">if</span>(s[now][<span class="number">1</span>] == <span class="string">'N'</span>)<span class="keyword">return</span> w[now] = dfs(ch[now][<span class="number">0</span>]) ^ <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> w[now] = check(now, dfs(ch[now][<span class="number">0</span>]), dfs(ch[now][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> de)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s[now][<span class="number">1</span>] == <span class="string">'N'</span>)&#123;</span><br><span class="line">ok[now] = de &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">0</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">0</span>], ok[now]);</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">0</span>]] = ok[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[now][<span class="number">1</span>] == <span class="string">'X'</span>)&#123;</span><br><span class="line">ok[now] = de &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">0</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">0</span>], ok[now]);</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">0</span>]] = ok[now];</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">1</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">1</span>], ok[now]);</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">1</span>]] = ok[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[now][<span class="number">1</span>] == <span class="string">'O'</span>)&#123;</span><br><span class="line">ok[now] = de &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">0</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">0</span>], ok[now] &amp; (w[ch[now][<span class="number">1</span>]] != <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">0</span>]] = ok[now] &amp; (w[ch[now][<span class="number">1</span>]] != <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">1</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">1</span>], ok[now] &amp; (w[ch[now][<span class="number">0</span>]] != <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">1</span>]] = ok[now] &amp; (w[ch[now][<span class="number">0</span>]] != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[now][<span class="number">1</span>] == <span class="string">'A'</span>)&#123;</span><br><span class="line">ok[now] = de &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">0</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">0</span>], ok[now] &amp; (w[ch[now][<span class="number">1</span>]] == <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">0</span>]] = ok[now] &amp; (w[ch[now][<span class="number">1</span>]] == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(s[ch[now][<span class="number">1</span>]][<span class="number">1</span>] != <span class="string">'I'</span>)dfs(ch[now][<span class="number">1</span>], ok[now] &amp; (w[ch[now][<span class="number">0</span>]] == <span class="number">1</span>));</span><br><span class="line"><span class="keyword">else</span> ok[ch[now][<span class="number">1</span>]] = ok[now] &amp; (w[ch[now][<span class="number">0</span>]] == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">memset</span>(w, <span class="number">-1</span>, <span class="keyword">sizeof</span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(s[i][<span class="number">1</span>] == <span class="string">'I'</span>)w[i] = read();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i][<span class="number">1</span>] == <span class="string">'A'</span> || s[i][<span class="number">1</span>] == <span class="string">'X'</span> || s[i][<span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">ch[i][<span class="number">0</span>] = read(), ch[i][<span class="number">1</span>] = read();</span><br><span class="line"><span class="keyword">else</span> ch[i][<span class="number">0</span>] = read();</span><br><span class="line">&#125; w[<span class="number">1</span>] = dfs(<span class="number">1</span>); dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(s[i][<span class="number">1</span>] == <span class="string">'I'</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>, w[<span class="number">1</span>] ^ ok[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Summary : <del>水题集合</del></p>]]></content>
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 斐蜀定理 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOIP2017TG Solution</title>
      <link href="/2017/11/12/NOIP2017%E9%A2%98%E8%A7%A3/"/>
      <url>/2017/11/12/NOIP2017%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><span class="math inline">\(Naive\)</span>选手爆零记 <img src="http://r.photo.store.qq.com/psb?/V12wIROa0MTsCi/BLq7XBuIeMPeTY*n.rzz8dfbNeInAwd.h0XLFoj59VI!/r/dDABAAAAAAAA"></p><a id="more"></a><h2 id="noip2017-d1t1小凯的疑惑"><a href="https://www.luogu.org/problemnew/show/3951" target="_blank" rel="noopener">NOIP2017 D1T1小凯的疑惑</a></h2><p><a href="https://www.luogu.org/problemnew/show/2737" target="_blank" rel="noopener">luogu P2737</a>麦香牛块Beef McNuggets 原题弱化版。</p><p>数论题，个人感觉并没有什么意义（在NOIP上考）既不考查代码能力，也只会增加其他人的翻车几率（逃 <strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(n<span class="number">-1</span>)*(m<span class="number">-1</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边给出证明。</p><p>定理: 对于正整数<span class="math inline">\(p,q\)</span>满足<span class="math inline">\(gcd(p,q)=1\)</span>,我们有<span class="math inline">\(px+qy=n\)</span>无非负整数解的最大正整数<span class="math inline">\(n\)</span>为<span class="math inline">\(pq−p−q\)</span>. 证明如下:</p><p>我们首先利用反证法, 证明<span class="math inline">\(px + qy \ne pq - p - q\)</span>: 我们假设存在正整数<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>使得<span class="math inline">\(px + qy = pq - p - q\)</span>, 则有</p><p><span class="math display">\[px + qy = pq - p - q\]</span> <span class="math display">\[p(x + 1) + q(y + 1) = p\]</span> <span class="math display">\[\because gcd(p, q) = 1,p | q(y + 1)\]</span> <span class="math display">\[\therefore p | y + 1 \]</span> 同理, <span class="math display">\[q | x + 1\]</span> 接着我们令<span class="math inline">\(y + 1 = pj\)</span>,$ x + 1 = qk$. 则有</p><p><span class="math display">\[pqk + qpj = pq \]</span> <span class="math display">\[pq(j + k) = pq\]</span> 注意到<span class="math inline">\(x, y \ge 0\)</span>, 我们有<span class="math inline">\(y + 1 \ge 1\)</span>且<span class="math inline">\(x + 1 \ge 1\)</span>, 因而<span class="math inline">\(j \ge 1\)</span>且<span class="math inline">\(k \ge 1\)</span>. 因而<span class="math inline">\(j + k \ge 2\)</span>, 因而假设不成立.</p><p>得证.</p><p><a href="https://www.luogu.org/wiki/show?name=%E9%A2%98%E8%A7%A3+P3951" target="_blank" rel="noopener">证明转自</a></p><h2 id="noip2017-d1t2时间复杂度"><a href="https://www.luogu.org/problemnew/show/3952" target="_blank" rel="noopener">NOIP2017 D1T2时间复杂度</a></h2><p>看到这道题就心疼，NOIP的时候并没有写出来，可能是因为并没有学栈的原因，所以当时没有写出来，今天学长们讲了栈，我就来把这道题A了 学长们还说递归可以A来着，<sub>好像还很简单</sub> <strong>思路</strong>： 好像并没有什么思路，就是遇到<span class="math inline">\(F\)</span>就就压栈，遇到<span class="math inline">\(E\)</span>就把最上层的栈弹出，大概像循环嵌套，括号匹配，表达式求值都可以用栈实现吧！ <strong>传送门</strong>：<a href="https://www.luogu.org/problemnew/show/1981" target="_blank" rel="noopener">NOIP2013普及组 表达式求值</a>,<a href="https://www.luogu.org/problemnew/show/1054" target="_blank" rel="noopener">NOIP2005提高组T4 等价表达式</a>(毒瘤题，数据很鬼畜) <strong>代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">11</span>][<span class="number">20</span>],e[<span class="number">11</span>][<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> T,judge[<span class="number">1</span>&lt;&lt;<span class="number">9</span>],deepth,is[<span class="number">1</span>&lt;&lt;<span class="number">9</span>],top,maxdeepth,fff,ff;</span><br><span class="line"><span class="comment">//ff是一个标记，来记录是否有重读的变量</span></span><br><span class="line"><span class="comment">//fff也是一个标记，用于记录一个循环的初始值大于结束值的请况</span></span><br><span class="line"><span class="comment">//top表示当前栈指向哪一层</span></span><br><span class="line"><span class="comment">//maxdeepth用来记录此程序的循环嵌套的最大层数</span></span><br><span class="line"><span class="comment">//deepth用于更新</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">11</span>][<span class="number">110</span>][<span class="number">5</span>],x;</span><br><span class="line"><span class="keyword">int</span> L,a,b,len,lennum,realdeepth;</span><br><span class="line"><span class="comment">//realdeepth就是输入所给的复杂度</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> is,isdi,deep;&#125;st[<span class="number">11</span>][<span class="number">110</span>];</span><br><span class="line"><span class="comment">//一个手写结构体的栈，用来记录状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("complexity.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("complexity.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;L);getchar();len=<span class="number">0</span>;realdeepth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> s=getchar();</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="string">'\n'</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)realdeepth=realdeepth*<span class="number">10</span>+s-<span class="string">'0'</span>;<span class="comment">//算realdeepth</span></span><br><span class="line">            ans[i][++len]=s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//memset(st,0,sizeof(st));</span></span><br><span class="line">        <span class="built_in">memset</span>(judge,<span class="number">0</span>,<span class="keyword">sizeof</span>(judge));</span><br><span class="line">        <span class="built_in">memset</span>(is,<span class="number">0</span>,<span class="keyword">sizeof</span>(is));</span><br><span class="line">        ff=<span class="number">0</span>;top=<span class="number">0</span>;maxdeepth=<span class="number">0</span>;deepth=<span class="number">0</span>;fff=<span class="number">1</span>;a=<span class="number">0</span>;b=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每一组数据都要初始化所有的标记，不要忘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;j++)&#123;</span><br><span class="line">            len=<span class="number">0</span>;x=<span class="number">0</span>;lennum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> s=getchar();</span><br><span class="line">                <span class="keyword">if</span>(s!=<span class="string">'\n'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s&gt;=<span class="string">'0'</span>&amp;&amp;s&lt;=<span class="string">'9'</span>)e[i][j][++len]=s,x=x*<span class="number">10</span>+s-<span class="string">'0'</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((s&gt;=<span class="string">'a'</span>&amp;&amp;s&lt;=<span class="string">'z'</span>&amp;&amp;s!=<span class="string">'n'</span>)||(s&lt;=<span class="string">'Z'</span>&amp;&amp;s&gt;=<span class="string">'A'</span>))e[i][j][++len]=s;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'n'</span>)e[i][j][++len]=s,x=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;<span class="comment">//n就标记为（1&lt;&lt;30）</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">' '</span>)&#123;</span><br><span class="line">                        e[i][j][++len]=s;</span><br><span class="line">                        <span class="keyword">if</span>(x)num[i][j][++lennum]=x,x=<span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//我是直接把循环中的两个值提取出来了，用整形来存比较好用</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">'\n'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x)num[i][j][++lennum]=x,x=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(e[i][j][<span class="number">1</span>]==<span class="string">'E'</span>)a++;<span class="comment">//预判ERR</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e[i][j][<span class="number">1</span>]==<span class="string">'F'</span>)b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;<span class="built_in">printf</span>(<span class="string">"ERR\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=L;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i][j][<span class="number">1</span>]==<span class="string">'F'</span>)&#123;</span><br><span class="line">                st[i][++top].isdi=e[i][j][<span class="number">3</span>];</span><br><span class="line">                st[i][top].deep=deepth;<span class="comment">//记录入栈时的deepth</span></span><br><span class="line">                <span class="keyword">if</span>(judge[e[i][j][<span class="number">3</span>]])ff=<span class="number">1</span>;<span class="comment">//重复就记录</span></span><br><span class="line">                <span class="keyword">else</span> judge[e[i][j][<span class="number">3</span>]]=<span class="number">1</span>;<span class="comment">//标记变量</span></span><br><span class="line">                <span class="keyword">if</span>(ff)<span class="keyword">break</span>;<span class="comment">//退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(num[i][j][<span class="number">1</span>]!=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))&#123;<span class="comment">//判断两个变量的初始值和末状态值</span></span><br><span class="line">                    <span class="keyword">if</span>(num[i][j][<span class="number">2</span>]&gt;=num[i][j][<span class="number">1</span>]&amp;&amp;num[i][j][<span class="number">2</span>]!=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))st[i][top].is=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(num[i][j][<span class="number">2</span>]&lt;num[i][j][<span class="number">1</span>]&amp;&amp;num[i][j][<span class="number">2</span>]!=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))st[i][top].is=<span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">//记录一个循环的初始值大于结束值的请况，且is=-1</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(num[i][j][<span class="number">2</span>]==(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))st[i][top].is=<span class="number">2</span>;<span class="comment">//不是常数的话is为2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(num[i][j][<span class="number">1</span>]==(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(num[i][j][<span class="number">2</span>]!=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))st[i][top].is=<span class="number">-1</span>;<span class="comment">//同理</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(num[i][j][<span class="number">2</span>]==(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))st[i][top].is=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(st[i][top].is==<span class="number">-1</span>)fff--;</span><br><span class="line">                <span class="comment">//把标记--，应为有可能多层都是不合法的循环（我一开始就是被这个坑了，结果debug了好长时间）</span></span><br><span class="line">                <span class="keyword">if</span>(st[i][top].is==<span class="number">2</span>&amp;&amp;fff==<span class="number">1</span>)deepth++;<span class="comment">//合法就更新deepth</span></span><br><span class="line">                maxdeepth=max(maxdeepth,deepth);<span class="comment">//看是否可以更新maxdeepth</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e[i][j][<span class="number">1</span>]==<span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i][top].is==<span class="number">-1</span>)fff++;</span><br><span class="line">                judge[st[i][top].isdi]=<span class="number">0</span>;</span><br><span class="line">                deepth=st[i][top].deep;</span><br><span class="line">                top--;</span><br><span class="line">                <span class="comment">//还原所有的标记，有点像递归回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ff)&#123;<span class="built_in">printf</span>(<span class="string">"ERR\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[i][<span class="number">3</span>]==<span class="string">'n'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(realdeepth==maxdeepth)<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[i][<span class="number">3</span>]&gt;=<span class="string">'0'</span>&amp;&amp;ans[i][<span class="number">3</span>]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxdeepth==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断输出就没有什么好说的了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="noip2017-d2t1奶酪"><a href="https://www.luogu.org/problemnew/show/3958" target="_blank" rel="noopener">NOIP2017 D2T1奶酪</a></h2><p>这题嘛其实跟luogu上的一道题很像，因为被那道题卡了很久所以NOIp一下就想到了，但那道题是一个二维的，这个题改成了三维，这个几乎上是没有什么影响的，就是距离公式变了而已，还有就是那道题是要构造最小生成树，而NOIp的这道只用判断两个边界是否联通就好了，其实NOIp的比luogu上的这道还好写一些<a href="https://www.luogu.org/problemnew/show/1783" target="_blank" rel="noopener">传送门 P1783 海滩防御</a></p><p>主要思路</p><blockquote><p>将所有点都存入一个数组，然后把两个边界都存进去，然后跑一个<span class="math inline">\(N^2\)</span> 就行了，这里就不多赘述，具体的细节处理见代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line">int T,n,h,r,fa[1100];</span><br><span class="line">struct node&#123;int x,y,z;&#125;t[21][1100];</span><br><span class="line">int findx(int x)&#123;</span><br><span class="line">    if(fa[x]==x)return fa[x];</span><br><span class="line">    return fa[x]=findx(fa[x]);//并查集压缩路径（mmp考试的时候太紧张了把压缩路径敲掉了，直接return findx(fa[x])掉了50分还是60分，心疼啊！！所以压缩路径一定不能掉）</span><br><span class="line">&#125;</span><br><span class="line">void mergex(int x,int y)&#123;fa[findx(x)]=findx(y);&#125;//合并函数</span><br><span class="line">double dis(int x,int y,int z,int x2,int y2,int z2)&#123;</span><br><span class="line">    ll disx,disy,disz;</span><br><span class="line">    disx=(ll)(x-x2)*(x-x2);disy=(ll)(y-y2)*(y-y2);disz=(ll)(z-z2)*(z-z2);</span><br><span class="line">    return sqrt(disx+disz+disy);</span><br><span class="line">&#125;</span><br><span class="line">//这个是求两点之间距离的函数，值得一提的是这个函数要用到开方，但是开方的运算量是很大的，也就是常数很大，要是出题人搞几组毒瘤数据估计又要死一片（比如说我），所以你可以改成return 一个乘积，代码我也会贴到下面（不过是我高二学长的）</span><br><span class="line">int main()&#123;</span><br><span class="line">    //freopen(&quot;cheese.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    //freopen(&quot;cheese.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    for(int i=1;i&lt;=T;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;h,&amp;r);</span><br><span class="line">        for(int j=0;j&lt;=n+1;j++)fa[j]=j;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            int x,y,z;scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            t[i][j].x=x;t[i][j].y=y;t[i][j].z=z;</span><br><span class="line">        &#125;t[i][n+1].z=h;</span><br><span class="line">        for(int j=0;j&lt;=n+1;j++)</span><br><span class="line">            for(int k=0;k&lt;=n+1;k++)&#123;</span><br><span class="line">                int x,y,z,x2,y2,z2,disr=r*2;</span><br><span class="line">                x=t[i][j].x;y=t[i][j].y;z=t[i][j].z;</span><br><span class="line">                x2=t[i][k].x;y2=t[i][k].y;z2=t[i][k].z;</span><br><span class="line">                if(j==0||j==n+1)&#123;x=x2,y=y2;disr=r;&#125;//边界特判</span><br><span class="line">                if(k==0||k==n+1)&#123;x2=x,y2=y;disr=r;&#125;//边界特判</span><br><span class="line">                double dist=dis(x,y,z,x2,y2,z2);</span><br><span class="line">                if(dist&lt;=disr)mergex(j,k);//如果可以就合并然后</span><br><span class="line">            &#125;</span><br><span class="line">        if(findx(0)==findx(n+1))printf(&quot;Yes\n&quot;);//如果联通就输出</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：我这个代码一看就很low，也很慢跑了800多ms，下面再来看看我学长的代码，这个只跑了150ms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e4;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct Point &#123;</span><br><span class="line">    int x, y, z; </span><br><span class="line">    void read() &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">struct MFS &#123;</span><br><span class="line">    int fa[maxn];</span><br><span class="line">    void clear(int x) &#123;</span><br><span class="line">        for (int i = 1; i &lt;= x; i++) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    int find(int x) &#123;</span><br><span class="line">        return x == fa[x] ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    void merge(int x, int y) &#123;</span><br><span class="line">        if (find(x) == find(y)) return;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s;</span><br><span class="line">ll dis(Point a, Point b) &#123;</span><br><span class="line">    ll x = (ll)a.x - b.x;</span><br><span class="line">    ll y = (ll)a.y - b.y;</span><br><span class="line">    ll z = (ll)a.z - b.z;</span><br><span class="line">    return x * x + y * y + z * z;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    //freopen(&quot;cheese.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    //freopen(&quot;cheese.out&quot;, &quot;w&quot;, stdout);    </span><br><span class="line">    int T; scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--) &#123;</span><br><span class="line">        int n, h, r; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;h, &amp;r);</span><br><span class="line">        int S = n + 1, T = n + 2;</span><br><span class="line">        ll R = ((ll)r * 2) * ((ll)r * 2);</span><br><span class="line">        s.clear(n + 2);</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            p[i].read();    </span><br><span class="line">            if ((ll)p[i].z - r &lt;= 0) s.merge(i, S);</span><br><span class="line">            if ((ll)p[i].z + r &gt;= h) s.merge(i, T);</span><br><span class="line">        &#125;</span><br><span class="line">        bool suc = false;</span><br><span class="line">        for (int i = 1; i &lt;= n &amp;&amp; !suc; i++) </span><br><span class="line">            for (int j = i + 1; j &lt;= n &amp;&amp; !suc; j++)</span><br><span class="line">                if (dis(p[i], p[j]) &lt;= R) &#123;</span><br><span class="line">                    s.merge(i, j);</span><br><span class="line">                    if (s.find(S) == s.find(T)) suc = true;</span><br><span class="line">                &#125;</span><br><span class="line">        if (s.find(S) == s.find(T)) suc = true;</span><br><span class="line">        if (suc) printf(&quot;Yes\n&quot;);</span><br><span class="line">        else printf(&quot;No\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">5</span><br><span class="line">1 6 4293</span><br><span class="line">3 3 -2</span><br><span class="line">1 9 866</span><br><span class="line">-4 4 3</span><br><span class="line">1 9 3171</span><br><span class="line">2 0 -3</span><br><span class="line">1 10 1940</span><br><span class="line">1 0 -5</span><br><span class="line">1 8 4150</span><br><span class="line">1 0 -4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>一看就很高端，还把最小生成树（MFS）封装了，我也不是很懂，dalao就看看把！！！ ## <a href="https://www.luogu.org/problemnew/show/P3959" target="_blank" rel="noopener">D2T2 宝藏</a> 这道题一看就应该是状压DP,这道题的题目就不多赘述了 用dp[i]来表示状态i下的最优方案,dis[j]表示j到根节点的距离（题目中所描述的K）用dfs来更新答案，下面直接上代码，<code>代码附注释</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">13</span>],dis[<span class="number">15</span>],G[<span class="number">15</span>][<span class="number">15</span>],isG[<span class="number">15</span>][<span class="number">15</span>],n,m,ans=inf;</span><br><span class="line"><span class="comment">//isG表示x,y之间是否有边</span></span><br><span class="line"><span class="comment">//点只有十二个直接上邻接矩阵即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;G[x][y]=w;G[y][x]=w;isG[x][y]=<span class="number">1</span>;isG[y][x]=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">//插边函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="comment">//枚举你所选点集中的每个点</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))&amp;x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)&amp;x)&amp;&amp;isG[i][j])</span><br><span class="line">                <span class="comment">//判断能否选</span></span><br><span class="line">                    <span class="keyword">if</span>(dp[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)|x]&gt;dp[x]+dis[i]*G[i][j])&#123;</span><br><span class="line">                    <span class="comment">//有没有更新的必要</span></span><br><span class="line">                        <span class="keyword">int</span> temp=dis[j];</span><br><span class="line">                        dis[j]=dis[i]+<span class="number">1</span>;</span><br><span class="line">                        dp[<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)|x]=dp[x]+dis[i]*G[i][j];</span><br><span class="line">                        dfs(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)|x);</span><br><span class="line">                        dis[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(G,<span class="number">63</span>,<span class="keyword">sizeof</span>(G));<span class="comment">//赋较大初值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w;<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">        <span class="keyword">if</span>(w&lt;G[x][y])insert(x,y,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">63</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;j++)dp[j]=inf;</span><br><span class="line">        <span class="comment">//每枚举一遍根节点就重置一遍</span></span><br><span class="line">        dis[i]=<span class="number">1</span>;dp[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">        ans=min(ans,dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);<span class="comment">//看答案是否能更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 模拟 </tag>
            
            <tag> dfs </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
